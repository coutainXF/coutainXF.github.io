<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>类和策略模式（strategy） | 晓枫的博客</title><script>var config = {"root":"/","search":{"preload":true,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="晓枫的博客" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>类和策略模式（strategy）</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-04-12T02:08:11.000Z" id="date"> 2023-04-12</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-04-12T05:42:14.000Z" id="updated"> 2023-04-12</time></div></span></div></div><hr><div id="post-content"><h1 id="策略模式封装了变化"><a href="#策略模式封装了变化" class="headerlink" title="策略模式封装了变化"></a>策略模式封装了变化</h1><p>面向对象编程——并非类越多越好，不至于每一个功能的实现都写一个具体的类，而是<strong>抽象出他们之间的共性</strong>，类的划分是为了封装，但是分类的基础是抽象，<strong>具有相同属性和功能的对象的抽象集合</strong>才是类。</p>
<h2 id="策略模式解析："><a href="#策略模式解析：" class="headerlink" title="策略模式解析："></a>策略模式解析：</h2><p>策略模式是一种定义一系列算法的方法，从概念上面来看，所有的算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少各种算法类与使用算法类之间的耦合。  </p>
<hr>
<h2 id="策略模式优点："><a href="#策略模式优点：" class="headerlink" title="策略模式优点："></a>策略模式优点：</h2><ol>
<li><p>Strategy类层次为Context定义了一系列的可供重用的算法和行为。继承有助于析取出这些算法中的公用功能。（例如CashContext中的GetResult来自于CashSuper）</p>
</li>
<li><p>策略模式的优点就是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口独立测试。 (哪个算法出了问题，只需要修改对应的算法即可。)</p>
</li>
<li><p><strong>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。</strong></p>
</li>
<li><p>策略模式避免了过多条件判断（if-else）语句的使用 </p>
</li>
</ol>
<h2 id="策略模式是怎么避免过多的条件判断的？"><a href="#策略模式是怎么避免过多的条件判断的？" class="headerlink" title="策略模式是怎么避免过多的条件判断的？"></a>策略模式是怎么避免过多的条件判断的？</h2><ul>
<li><p>策略模式就是用来封装算法的，但在实践当中，我们发现它可以用它来封装几乎任何类型的规则，只要在分析过程中知道需要在不同时间（不同应用场合）应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。 </p>
</li>
<li><p>基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context上下文对象。  </p>
</li>
<li><p>在结合了工厂和策略模式后，选择所用具体实现的职责也可以由Context承担，最大化减轻了客户端的职责。  </p>
</li>
<li><p>要增加一种算法的话，还是需要增加Context对象中的switch分支  </p>
</li>
<li><p>但是——无论如何，任何需求的变更都是需要成本的。  </p>
</li>
<li><p>只是成本开销大小的关系，面对同样的需求当然成本开销越小越好。  </p>
</li>
<li><p>还提到一种反射技术——策略模式的改进</p>
</li>
</ul>
<p><font color="red"><strong>封装变化点的思想</strong>——Context上下文对象，通过使不同算法实现类继承同一个父类，创建该父类的一个引用来装载子类对象（父类可以装子类——就比如说Object对象可以装载所有的对象），通过这个父类的引用去调用不同子类中的算法实现。</font></p>
<h2 id="主要的问题："><a href="#主要的问题：" class="headerlink" title="主要的问题："></a>主要的问题：</h2><p>怎么装载子类？<br>——通过子类继承同一个父对象，创建一个父对象的引用来装载。<br>怎么装载不同的子类？<br>——通过<strong>构造方法</strong>传入<strong>不同策略对象</strong>来构造对不同子类的引用。<br>怎么调用子类的方法？<br>——子类通过继承override重写父类中的方法，然后通过父类的引用（这时候装载了子类）直接调用该方法即可。</p>
<h3 id="实例：商场打折促销、满减促销等不同营销策略的实现——结合CashFactory——收费工厂类"><a href="#实例：商场打折促销、满减促销等不同营销策略的实现——结合CashFactory——收费工厂类" class="headerlink" title="实例：商场打折促销、满减促销等不同营销策略的实现——结合CashFactory——收费工厂类"></a>实例：商场打折促销、满减促销等不同营销策略的实现——结合CashFactory——收费工厂类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs csharp">商场打折促销、满减促销等不同营销策略的实现——<br><br>    CashSuper——父类<br>    CashNormal——算法<span class="hljs-number">1</span>对应一个策略：常规收费<br>    CashRebate——算法<span class="hljs-number">2</span>对应一个策略：打折收费<br>    CashReturn——算法<span class="hljs-number">3</span>对应一个策略：满返收费<br>    CashContext——收费上下文<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span></span><br>        可以在此继续拓展其他的策略类<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span></span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CashContext</span>&#123;<br>        <span class="hljs-keyword">private</span> CashSuper cs;<span class="hljs-comment">//创建父类对象的引用</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CashContext</span>(<span class="hljs-params">CashSuper csuper</span>)<span class="hljs-comment">//通过传入具体的收费策略</span></span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.cs = csuper;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetResult</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> money</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> cs.AcceptCash(money);<br>        &#125;<br>    &#125;<br><br><br>结合CashFactory——收费工厂类<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CashSuper <span class="hljs-title">createCashAccept</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> type</span>)</span><br>    &#123;<br>        CashSuper cs = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (type)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;常规收费&quot;</span>:&#123; cs = <span class="hljs-keyword">new</span> CashNormal( ); <span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;打折收费&quot;</span>:&#123; cs1 = <span class="hljs-keyword">new</span> CashRebate( <span class="hljs-number">0.8</span>);<span class="hljs-keyword">break</span>; &#125;<br>            <span class="hljs-comment">/*打折力度0.8*/</span> <br>            <span class="hljs-keyword">case</span>……<br>            <span class="hljs-comment">//根据type传入不同的收费策略实例化不同分支收费算法类</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> cs;<br>    &#125;<br><br><br>客户端代码(main函数)<br>    CashContext cc=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">int</span> num)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:&#123; <br>        cc = <span class="hljs-keyword">new</span> CashContext( <span class="hljs-keyword">new</span> CashNormal ( ) ) ;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:&#123;<br>        cc = <span class="hljs-keyword">new</span> CashContext( <span class="hljs-keyword">new</span> CashRebate( <span class="hljs-number">0.8</span> ) ) ;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        …<br>    &#125;<br>    <span class="hljs-built_in">double</span> total=<span class="hljs-number">0f</span>;<br>    total += cc.GetResult();<br>    …<br><br>可以发现——客户端中又多了这个<span class="hljs-keyword">switch</span>判断的过程，将它转移是可以做到的<br>——简单工厂不一定要是单独的一个类，它可以和策略模式的Context上下文对象结合。<br></code></pre></td></tr></table></figure>

<h3 id="结合简单工厂和策略模式——修改后的CashContext"><a href="#结合简单工厂和策略模式——修改后的CashContext" class="headerlink" title="结合简单工厂和策略模式——修改后的CashContext"></a>结合简单工厂和策略模式——修改后的CashContext</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">结合简单工厂和策略模式——修改后的CashContext<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">CashContext</span><br>&#123;<br>    CashContext cc=<span class="hljs-literal">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CashContext</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> type</span>)<span class="hljs-comment">//注意参数类型</span></span><br>    &#123;<br>        <span class="hljs-keyword">switch</span>(type)<br>        &#123;<br>            <span class="hljs-keyword">case</span>:<span class="hljs-string">&quot;常规收费&quot;</span>:&#123; <br>            cc = <span class="hljs-keyword">new</span> CashContext( <span class="hljs-keyword">new</span> CashNormal ( ) ) ;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span>:<span class="hljs-string">&quot;打折收费&quot;</span>:&#123;<br>            cc = <span class="hljs-keyword">new</span> CashContext( <span class="hljs-keyword">new</span> CashRebate( <span class="hljs-number">0.8</span> ) ) ;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            …<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetResult</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> money</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> cs.acceptCash(money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="看看两种方式调用的区别："><a href="#看看两种方式调用的区别：" class="headerlink" title="看看两种方式调用的区别："></a>看看两种方式调用的区别：</h2><p>//用工厂方式<br>CashSuper csuper = CashFactory.createFactory(string type);<br>//工厂和策略模式的结合<br>CashContext cashContext = new CashContext(string type);</p>
<h2 id="结合工厂模式与策略模式的好处："><a href="#结合工厂模式与策略模式的好处：" class="headerlink" title="结合工厂模式与策略模式的好处："></a>结合工厂模式与策略模式的好处：</h2><p>用工厂方式需要了解两个类对象CashSuper和CashFactory<br>用工厂和策略模式结合可以只了解上下文对象CashContext<br>这使得具体的收费算法彻底地与客户端分离，连算法的父类CashSuper都不对客户端开放。</p>
<h2 id="策略模式的思想："><a href="#策略模式的思想：" class="headerlink" title="策略模式的思想："></a>策略模式的思想：</h2><ul>
<li><font color="red">定义算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响使用该算法的客户。</font></li>
<li><font color="red">算法本身只是一种策略，最重要的是这些算法是随时可能互相替换的，这就是变化点，而封装变化点是我们面向对象的一种很重要的思维方式。</font></li>
</ul>
<h2 id="策略模式标准实现"><a href="#策略模式标准实现" class="headerlink" title="策略模式标准实现"></a>策略模式标准实现</h2><p>抽象算法类，Strategy<br>策略A继承自抽象算法（Strategy），ConcreteStrategyA<br>策略B继承自抽象算法（Strategy），ConcreteStrategyB<br>……<br>上下文对象，Context，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp">抽象算法类<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span><br>    &#123;<span class="hljs-comment">//算法方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span>;<br>    &#125;<br><br><br><span class="hljs-comment">//策略A——封装了具体的算法及行为，继承于Strategy</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> : <span class="hljs-title">Strategy</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//具体实现</span><br>        &#125;<br>    &#125;<br><br><br><span class="hljs-comment">//策略B——封装了具体的算法及行为，继承于Strategy</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> : <span class="hljs-title">Strategy</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AlgorithmInterface</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//具体实现</span><br>        &#125;<br>    &#125;<br><br><br><span class="hljs-comment">//上下文——Context,用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Context</span><br>    &#123;<br>        Strategy strategy;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span>(<span class="hljs-params">Strategy strategy</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.strategy = strategy;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContextInterface</span>()</span><br>        &#123;<br>            strategy.AlgorithmInterface();<br>        &#125;<br>    &#125;<br><br><br><br>客户端代码(main函数)：<br>    Context context;<br><br>    context = <span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyA( ));<br><br>    context.ContextInterface( );<span class="hljs-comment">//调用了策略A的算法实现</span><br><br>    context = <span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> ConcreteStrategyB( ));<br><br>    context.ContextInterface( );<span class="hljs-comment">//调用了策略B的算法实现</span><br></code></pre></td></tr></table></figure>

<p>客户端是如何调用不同的算法的：<br>实例化了上下文对象，传入了继承Strategy类的ConcreteStrategyA类实例化的对象来初始化Context对象中的Strategy参数，此时使用的便是具体实现策略A的算法。调用Context对象的方法，即是调用策略A的方法实现，策略模式就是通过这样的上下文对象封装了“变化点”，每次采取不同的策略，就传入不同的继承自策略类Strategy的具体策略的实例即可。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/12/DesignPattern/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator%EF%BC%89/">← Next 装饰模式（Decorator）</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/04/12/DesignPattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88SimpleFactory%EF%BC%89/">简单工厂模式（SimpleFactory） Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">晓枫</a></h1><div id="description"><p>想要壮志凌云<br>干要脚踏实地</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%B0%81%E8%A3%85%E4%BA%86%E5%8F%98%E5%8C%96"><span class="toc-text">策略模式封装了变化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-text">策略模式解析：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">策略模式优点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%EF%BC%9F"><span class="toc-text">策略模式是怎么避免过多的条件判断的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">主要的问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%95%86%E5%9C%BA%E6%89%93%E6%8A%98%E4%BF%83%E9%94%80%E3%80%81%E6%BB%A1%E5%87%8F%E4%BF%83%E9%94%80%E7%AD%89%E4%B8%8D%E5%90%8C%E8%90%A5%E9%94%80%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E7%BB%93%E5%90%88CashFactory%E2%80%94%E2%80%94%E6%94%B6%E8%B4%B9%E5%B7%A5%E5%8E%82%E7%B1%BB"><span class="toc-text">实例：商场打折促销、满减促销等不同营销策略的实现——结合CashFactory——收费工厂类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84CashContext"><span class="toc-text">结合简单工厂和策略模式——修改后的CashContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">看看两种方式调用的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-text">结合工厂模式与策略模式的好处：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-text">策略模式的思想：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">策略模式标准实现</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>