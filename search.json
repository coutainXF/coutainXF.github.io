[{"title":"创建卡牌游戏原型","url":"/2023/04/19/%E5%88%9B%E5%BB%BA%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F%E5%8E%9F%E5%9E%8B/","content":"创建卡牌游戏原型开发日志日志4.14\n没想到一个卡牌游戏项目的复杂程度能这么大，我感觉无从下手。\n日志4.15\n制作了简陋的UI界面，甚至几乎没有任何可以装载的图片。\n跑去制作了一个Python程序，用来批量处理md文件。\n日志4.16\n开始参考NueDeck代码模板进行开发。\n日志4.17\n创建卡牌行为枚举，创建了能够打出去并造成影响的卡牌。\n实现了卡牌行为中间间，并在GameApp中进行初始化。\n战斗的基本框架搭建完成。\n接下来的任务：\n1、制作抽牌、打牌动画，为卡牌添加特效、mana消耗\n2、制作玩家和关卡敌人的数据注入。\n日志4.18\n制作了卡牌、玩家、敌人的数据注入。\n并且对卡牌造成的影响能够正确做到。\n编写UI更新的逻辑。\n维护玩家卡组、抽牌堆、弃牌堆。\n4.19\n制作了敌人血条UI、敌人AI（固定行为模式和随机行为模式）\n尝试维护玩家抽牌堆、弃牌堆。\n\n\n4.20\n教训：如果你在尝试运行时修改ScriptableObject数据，将会引起一场灾难。\n最好只用来做数据的初始化。\n问题来源ScriptableObject：在运行时修改meta文件并保存上一次Play的运行结果，当你退出编辑器后（大退），修改会重置；如果SetDirty的话，会将数据保存。 \n开发过程中遇到的困难1、种子seed是怎么做的？这使得我难以复现同一局游戏。\n肉鸽的随机：拿一个初始随机数种子，只要遇到需要用到随机数的地方，就使用这个种子通过某种去生成一个新的种子，然后再将这个新种子保存起来，然后后面再用到的时候就用这个生成的新种子去生成，重复上面的。\n2、怎么提供保存机制？使得我能够从上次的进度中加载并继续。\n3、没有开发资源（图片、icon、音效等\n4、反射相关的内容。\n5、如何搭建策划也能使用的框架？\n-&gt;CardData为CardBase注入数据，让自定义卡牌不再充满苦难（悲\n6、程序执行顺序总是有问题，报空指针是最难受的（悲\n7、UI的更新逻辑使我头疼。\n8、Debug\nhighlight the text\n开发使用的版本/包/资源Universal RenderPine\nTextMeshPro\nCinemachine\nDOTween\nTrueShadow\nSpine-Unity=&gt;创建小人动画\n参考项目：\nNueDeck(一个代码模板，提供了Roguelike卡牌类游戏的基础功能)\nArefnue/NueDeck: Open source, roguelike deck-building card game template (github.com)\n导入开发使用的资源Spine骨骼动画（构成了角色的所有动画）\n一些卡牌图片、UI、GUI\n特效、粒子效果等\nicon来自Orders | Fanatical的RPG Game Builder Assets Kit（$15）\n创建并搭建场景1、主菜单场景\n2、GamePlay场景\n3、地图线路选择场景（Map）\n可以通过SceneLoader在场景中进行切换。\n创建Menu场景放置开始和退出按钮\n创建GamePlay场景搭建游玩时的UI界面\n包括顶部的通用设置界面\n\n  血量\n\n  主动道具\n\n  coins，用于购买的硬币\n\n  settings，设置按钮\n\n  collections，收藏品背包\n\n\n和底部的战斗界面\n\n  mana，打出卡牌需要消耗能量\n\n  end turn按钮，进入下一回合的按钮\n\n  cardsCanvas，用于存放卡牌的位置\n\n  抽牌堆\n\n  弃牌堆\n\n\n创建地图线路选择场景提供一个能够选择随机行进路线的地图。\n研究NueDeck框架内容1、大量使用ScriptableObject作为数据文件存储，用以快捷地配置数据。\n2、可以了解，卡牌类的游戏UI交互是不可或缺的一部分，甚至说比重相当大。\n3、回合制战斗：\n枚举实现\nenum CombatType&#123;    prepareCombat,-&gt;0，代表战斗前    playerTurn,-&gt;1，代表玩家回合    enemyTurn,-&gt;2，代表敌人回合    endCombat-&gt;3，代表战斗结束&#125;\n\npublic UnityAction OnPlayerTurnStart();//往里面添加监听public UnityAction OnEnemyTurnStart();//往里面添加方法switch(currentCombatType)&#123;     case CombatType.prepareCombat:        break;    case CombatType.playerTurn:        //监听玩家回合事件        //大概是抽卡drawCard、更新能量（打出手牌需要消耗能量）    case CombatType.enemyTurn:        //监听敌人回合事件    //case any other CombatType:    //在这里添加任何其他的战斗类型枚举&#125;\n\n//想必这里是其他的类，获取OnPlayerTurnStart事件为玩家订阅上述的方法：\n\n绘制框架图完成回合制卡牌GameLoop制作可以打出的卡牌UI\n  控制卡牌能够选中、缩放、拖拽\n\n  发牌动画以及打出卡牌后的动画\n\n\n卡牌管理\n  管理玩家的牌组（想必是一个 List 结构来存储相应的数据）。\n\n  管理玩家的抽牌堆、弃牌堆，提供抽牌、弃牌等方法。\n\n  调用UIManager来实现上述方法。\n\n  提供使用UseCard方法，调用DoAction来使用卡牌。\n\n  查看抽牌堆，查看弃牌堆\n\n\n制作UI管理器UIManager\n 控制玩家UI的显示=&gt;获取UI的画布组件，通过enable/disable，显示/隐藏UI\n 绘制卡牌，提供动画。\n 编写UI更新逻辑。\n\n制作回合制卡牌战斗系统CombatMananger\n  依据CombatType控制进入不同的回合。\n\n  做战斗的初始化工作：\n\n生成敌人(√)\n\n生成玩家（√）\n\n显示战斗UI（√）\n\n（待定）使用收藏品被动（）\n\n初始化CombatType为玩家回合。（√）\n\n\n\n\n有一个机制：存储和加载某个类创建的ScriptableObject存放了玩家的所有信息。\n在每次战斗的时候重新从那里加载信息。包括剩余血量、存放的内容等。\n创建一张能够打出去并造成影响的牌！\n  定义卡牌的行为抽象类，包含parameters和可能用到的组件\n\n  一个行为枚举，代表不同的行为\n\n  定义基础的几个卡牌行为\n\nAttack\n\nDefend\n\nDrawCard\n\nRestoreHealth\n\nStrength\n\n…other\n\n\n\n  定义使用卡牌方法，依据行为枚举来指定打出的牌\n\n  1、指定目标（包括self和target）\n\n  2、需要一个中间件来打出卡牌\n\n\n定义这个中间件：\n开始时自动初始化它。\n设置一个字典来存储所有的行为枚举-行为类实例。\n当打出卡牌时，给出字典[行为类型]即可获取行为类实例，执行DoAction来实现影响。\n\n  实现这个中间件\n\n  为这个中间件Debug\n\n  当什么时候使用卡牌方法？鼠标OnDrag的时候选择目标！！！\n\n  动态地构建Params？\n使用输入检测检测在onDrag的时候开启检测协程。\n检测协程在射线检测到hit2D的目标时，为param设置卡牌作用目标target\n否则只设置其他的参数：\nCardBase（当前打出的卡），\nBaseCharacter Self（指玩家）；\n在endDrag的时候关闭该协程。并将params置为null\n\n\n创建角色BaseCharacter创建玩家Player\n 数据注入\n\n创建敌人Enemy\n 同上\n\n完善卡牌Action（数据交互方面的内容）\n  1、消耗mana\n\n  2、使用AudioManager播放音效，指定卡牌Params为其提供audio\n\n  3、使用EffectManager播放特效，并在打出卡牌时播放动画。\n\n  4、为卡片添加描述等参数内容。\n\n  5、实现抽牌效果。\n\n  6、抽牌堆、弃牌堆等内容\n\n\n创建敌人AI\n 类似于创建卡牌的行为，创建敌人行为。\n\n![]()   ---&gt;  type this to add an image\n","categories":["--[Unity]"],"tags":["游戏原型","CardGame","Unity"]},{"title":"资源链接导航","url":"/2023/04/15/%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5%E5%AF%BC%E8%88%AA/","content":"资源链接导航Github存放了项目的源码、项目总结以及资源链接等\ncoutainXF (晓枫) (github.com)\n计算机科学与技术CS自学指南 (csdiy.wiki)\nPKUFlyingPig/cs-self-learning: 计算机自学指南 (github.com)\n计算机图形学计算机图形学与混合现实在线平台 – GAMES: Graphics And Mixed Environment Symposium (games-cn.org)\nGAMES101: 现代计算机图形学入门 (ucsb.edu)\nGAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili\n往期作业汇总帖 – 计算机图形学与混合现实在线平台 (games-cn.org)\nOpenGLJoeyDeVries/LearnOpenGL: Code repository of all OpenGL chapters from the book and its accompanying website https://learnopengl.com (github.com)\nhttps://learnopengl-cn.github.io/\nhttp://cg.cs.tsinghua.edu.cn/course/\nJava(455条消息) Java工程师的成长之路_java工程师成长之路_轻松的小希的博客-CSDN博客\n| Java 全栈知识体系 (nenggz.com)\nC# (CSharp)游戏开发Red Blob Games\ngonglei007/GameDevMind: 最全面的游戏开发技术图谱。帮助游戏开发者们在已知问题上节省时间，省出更多的精力投入到更有创造性的工作中去。 | The most comprehensive technical map of game development. Help game developers save time on known problems and save more energy for more creative work. (github.com)\nKavex/GameDev-Resources: A wonderful list of Game Development resources. (github.com)\ncrazyshader/GameDev: # Unity游戏开发资源 (github.com)\nThisisGame/cpp-game-engine-book: 从零编写游戏引擎教程 Writing a game engine tutorial from scratch (github.com)\ncandycat1992/Unity_Shaders_Book: 书籍《Unity Shader入门精要》源代码 (github.com)\nQianMo/Awesome-Unity-Shader: 关于炫酷的Unity3D Shader | About Cool Unity3D Shaders (github.com)\nXINCGer/Unity3DTraining: 【Unity杂货铺】unity大杂烩~ (github.com)\n游戏开发素材资源独立精神 | indienova 独立游戏\nDownload the latest indie games - itch.io\nHumble Bundle | game bundles, book bundles, software bundles, and more\nFanatical\niconfont-阿里巴巴矢量图标库\n算法和数据结构Data Structures | DS Tutorial - javatpoint\nTheAlgorithms/Java: All Algorithms implemented in Java (github.com)\ndunwu/algorithm-tutorial: 算法和数据结构教程 (github.com)\ndoocs/leetcode: 😏 LeetCode solutions in any programming language | 多种编程语言实现 LeetCode、《剑指 Offer（第 2 版）》、《程序员面试金典（第 6 版）》题解 (github.com)\n杂项（Misc）个人技术分享-程序员导航cxy521\nCyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计 (github.com)\n","categories":["--[资源链接]"],"tags":["资源","导航"]},{"title":"快速了解26种设计模式和常见的设计思想","url":"/2024/06/16/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A326%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"快速了解26种设计模式和常见的设计思想设计模式的不同类型创建型创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。\n结构型结构型模式（Structural Pattern）：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。\n行为型行为型模式（Behavioral Pattern）：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。\n创建型设计模式工厂模式（Factory Pattern），\n抽象工厂模式（Abstract Factory Pattern）\n单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n建造者模式（Builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。该模式实现了一个原型接口，该接口用于创建当前对象的克隆。\n结构型模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。\n装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。\n代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。外观类需要了解所有的子系统的方法或属性，进行组合，以备外界调用。\n桥接模式（Bridge），将抽象部分与它的实现部分分离，使它们可以独立地变化。实现指的是抽象类和它的派生类用来实现自己的对象。实现的方式有多种，桥接模式的思想就是把这些实现独立出来，让它们各自的变化，这样就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们的耦合。桥接模式是合成/聚合原则的完美体现。\n组合模式（Composite Pattern）依据树形结构来组合对象，用来表示部分以及整体层次。组件模式是将独立的功能点做一个封装，便于增删和管理。\n享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。运用共享技术有效地支持大量细粒度的对象。\n行为型模式策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。策略模式封装了“变化“\n模板模式（Template Pattern）就是通过抽象类来定义一个逻辑模板，逻辑框架、逻辑原型，然后将无法决定的部分抽象成抽象类交由子类来实现。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。\n观察者模式（Observer Pattern）定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当这个主题对象状态发生改变时，会通知所有的观察者对象，使他们能够自动更新自己。所以也称之为发布-订阅模式（Publish/Subscribe）。\n迭代器模式（Iterator Pattern）式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。\n命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。\n在状态模式（State Pattern）中，类的行为是基于它的状态改变的。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。\n在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。主要将数据结构与数据操作分离。主要解决：稳定的数据结构和易变的操作耦合问题。\n中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n设计思想与设计原则开闭原则（Open Closed Principle）一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。\n单一职责原则：应该有且仅有一个原因引起类的变更。\n里氏替换原则：子类必须能够替换父类，子类行为可以扩展但不能破坏父类行为，子类可以增加自己的特有方法，遵循父类的约束。\n依赖倒置原则：“面向接口编程”。依赖于抽象而不依赖于具体。\n迪米特法则（LoD）也叫最少知道法则：一个对象应该对其他对象有最少的了解。\n合成复用原则（Composite Reuse Principle）尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。\n","categories":["--[设计模式]"],"tags":["设计模式","计算机学科基础"]},{"title":"中介者模式（Mediator）","url":"/2023/04/12/DesignPattern/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Mediator%EF%BC%89/","content":"中介者模式（Mediator）中介者模式（Mediator），用一个中介对象来封装一系列的对象交互。中介使得各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n中介者模式结构图\n中介者模式代码结构    abstract class Mediator    &#123;        //定义一个抽象的发生消息方法，得到同事对象和发送消息。        public abstract void Send(string message,Colleague colleague);    &#125;    abstract class Colleague    &#123;        protected Mediator mediator;        public Colleague(Mediator mediator)        &#123;            this.mediator = mediator;        &#125;    &#125;    class ConcreteMediator : Mediator    &#123;        private ConcreteColleague1 colleague1;        public ConcreteColleague1 Colleague1        &#123;            set &#123; colleague1 = value; &#125;        &#125;        private ConcreteColleague2 colleague2;        public ConcreteColleague2 Colleague2        &#123;            set &#123; colleague2 = value; &#125;        &#125;        public override void Send(string message, Colleague colleague)        &#123;            if(colleague==colleague1)            &#123;                colleague2.Notify(message);            &#125;else            &#123;                colleague1.Notify(message);            &#125;        &#125;    &#125;    class ConcreteColleague1 : Colleague    &#123;        public ConcreteColleague1(Mediator mediator) : base(mediator)        &#123;        &#125;        public void Notify(string message) &#123; Console.WriteLine(&quot;同事1得到消息&quot;+message); &#125;        public void Send(string message) &#123; mediator.Send(message, this); &#125;    &#125;    class ConcreteColleague2 : Colleague    &#123;        public ConcreteColleague2(Mediator mediator) : base(mediator)        &#123;        &#125;        public void Notify(string message) &#123; Console.WriteLine(&quot;同事2得到消息&quot; + message); &#125;        public void Send(string message) &#123; mediator.Send(message,this); &#125;    &#125;//客户端代码：    ConcreteMediator mediator = new ConcreteMediator();    ConcreteColleague1 c1 = new ConcreteColleague1(mediator);    ConcreteColleague2 c2 = new ConcreteColleague2(mediator);//两个同事类均认识中介者对象    mediator.Colleague1 = c1;    mediator.Colleague2 = c2;    c1.Send(&quot;111&quot;);    c2.Send(&quot;222&quot;);            \n\n中介者模式总结\n尽管将一个系统分割成许多对象通常可以增加其复用性，但是对象间相互连接的激增又会降低其可复用性。\n\n大量的连接使得一个对象不能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的任何行为进行较大的改动就十分困难了。\n\n通过中介者模式，系统从复杂交织的网状结构变成了以中介者为中心的星形结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用吗，而是通过中介者对象与另一个对象发生相互作用。\n\n中介者模式一般应用在一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而不想产生过多子类的场合。\n\n\n中介者模式的缺点缺点很明显，所有的具体联系必须由中介者来定义，必须了解所有需要联系的类，此时将会使得中介者类过于复杂（责任过多）\n优点将考虑交互复杂性变为了中介者的复杂性，减轻了类联系的耦合性，将关注的对象从对象各自本身的行为转移到了它们之间的交互联系上。从更加宏观的角度看待系统。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"享元模式（Flyweight）","url":"/2023/04/12/DesignPattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight%EF%BC%89/","content":"享元模式（Flyweight）享元模式（Flyweight），运用共享技术有效地支持大量细粒度的对象。\n享元模式结构图\n享元模式成员分析没看懂，也许后面会更新罢。\n享元模式代码结构/// FlyWeight类，它是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。abstract class Flyweight&#123;    public abstract void Operation(int extrinsicstate);&#125;/// ConcreteFlyweight类是继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间class ConcreteFlyweight : Flyweight&#123;    public override void Operation(int extrinsicstate)    &#123;        Console.Write(&quot;具体的Flyweight&quot; + extrinsicstate);    &#125;&#125;class UnsharedConcreteFlyweight : Flyweight&#123;    public override void Operation(int extrinsicstate)    &#123;        Console.WriteLine(&quot;不共享的具体Flyweight&quot; + extrinsicstate);    &#125;&#125;/// FlyweightFactory类，是一个享元工厂，用来创建并管理Flyweight对象。/// 它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，/// FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。class FlyweightFactory&#123;    private Hashtable flyweights = new Hashtable();    //初始化工厂时，生成3个实例    public FlyweightFactory()    &#123;        flyweights.Add(&quot;x&quot;, new ConcreteFlyweight());        flyweights.Add(&quot;y&quot;, new ConcreteFlyweight());        flyweights.Add(&quot;z&quot;, new ConcreteFlyweight());    &#125;    //根据客户端的请求，获得已生成的实例    public Flyweight GetFlyweight(string key)    &#123;        return (Flyweight)flyweights[key];    &#125;&#125;\n\n享元模式总结问题：\n一定要在工厂里面事先实例化对象实例嘛？  \n不一定，可以在工厂实例化时什么都不做，到需要使用时，再判断GetFlyweight(key)是否为null，是则实例化一个对象实例。  \nUnshared的享元存在的意义何在？  \n有一些时候的特例，有可能存在不需要共享的实例对象。\n关键内部状态和外部状态\n享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本相同，有时就能够大幅度地减少需要实例化的类的数量。如果能够把那些参数移到类实例的外面，在方法调用时再将它们传递进来，就可以通过共享去大幅度地减少单个实例的数目。  \n内部状态存储在具体享元当中\n将外部状态作为方法参数存放于具体享元的方法中\n考虑将外部状态放在客户端中存储或计算。\n享元模式应用场景如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时，应该考虑使用享元模式。\n此外，如果对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。\n游戏开发中的享元模式享元模式用于在多个对象之间共享相同的数据。  \n例如，游戏场景中的一些植被和重复得小物件，它们的贴图或是网格都是一样的，可以创建一个公共的对象来记录这些数据，我称之为共享数据，然后他们的位置，朝向可能都不一样，这些数据我称之为私有数据。  \n如我们要在游戏场景中绘制1k棵树，在未使用享元模式之前：\nclass Tree｛private:  Mesh mesh_;  Texture bark_;  Texture leaves_;  Vector position_;  double height_;  double thickness_;  Color barkTint_;  Color leafTint_;｝;\n\n使用享元模式之后：\nclass TreeModel｛private:  Mesh mesh_;  Texture bark_;  Texture leaves_;｝;class Tree｛private:  TreeModel* model_;  Vector position_;  double height_;  double thickness_;  Color barkTint_;  Color leafTint_;｝;\n\n这样我们就只需要创建一个Model对象，让所有的树都引用这份数据，而不是每棵树都拥有自己的网格数据，可以节约内存。以上例子来源于《游戏设计模式》。  \n使用享元模式的前提是，他们的数据必须是可以共享的，即有相同的数据。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"代理模式（Proxy）","url":"/2023/04/12/DesignPattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89/","content":"代理模式（Proxy）代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n代理模式结构图\n代理模式代码结构Subject类，定义了公共接口，描述实体类和代理类共同的行为。这样就可以在任何使用实体类的地方使用代理类。abstract class Subject&#123;    public abstract void Request( );&#125;class RealSubject ：Subject&#123;    public override void Request()    &#123;        //实体类的请求。    &#125;&#125;class Proxy ：Subject&#123;    RealSubject realSubject;    public override void Request( )    &#123;        if(realSubject == null)        &#123;            realSubject = new RealSubject( );        &#125;        realSubject.Request( );        //调同名的方法（继承自同一个接口）        //借此完成代理    &#125;&#125;客户端代码Proxy proxy = new Proxy();proxy.Request( );\n\n代理模式主要解决的问题在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n代理模式应用场合远程代理=&gt;也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。\n(275条消息)代理模式（三）：远程代理，虚拟代理，缓冲代理_SunnyMarkLiu的博客-CSDN博客\n虚拟代理=&gt;是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。例如（浏览器打开一个html网页，图片框代理了尚未下载的图片）安全代理=&gt;用来控制真实对象访问时的权限。一般用于对象应该有不同访问权限的时候。智能代理=&gt;是指当调用实际要使用的对象时，代理处理一些额外的事情。例如：\n\n计算真实对象的引用次数，当该对象没有引用时，可以自动释放它；\n当第一次引用一个持久化对象时，将它装入内存；\n在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。\n\n这样，就可以通过代理模式来为对象的调用提供额外的业务逻辑。总的来说：代理模式就是在访问对象的时候引入一定程度的间接性，因为这种间接性，可以附加多种用途。（逻辑增强，控制调用）说白了，代理就是真实对象的代表。\n使用代理模式的优点\n职责清晰真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。\n代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。\n高扩展性\n\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"单例模式（Singleton）","url":"/2023/04/12/DesignPattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89/","content":"单例模式（Singleton）单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。 \n通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是：让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。\n单例模式结构图\n单例模式代码结构单例模式经典实现单例模式代码结构class Singleton&#123;    private static Singleton instance;    /// &lt;summary&gt;    /// 构造方法让其私有化，这样就堵死了外界用new创建该类新实例的可能    /// &lt;/summary&gt;    private Singleton()    &#123;     &#125;    /// &lt;summary&gt;    /// 此方法是获取本类的唯一全局访问点    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Singleton GetInstance()    &#123;        //若实例不存在，则new一个实例，否则直接返回已有实例        if (instance == null)        &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;//客户端代码：Singleton s1 = Singleton.GetInstance();Singleton s2 = Singleton.GetInstance();if (s1 == s2)    Console.WriteLine(&quot;两者相同&quot;);else    Console.WriteLine(&quot;两者不同&quot;);\n\n多线程下的单例模式多线程时的单例模式class SingletonSync&#123;    private static SingletonSync instance;    private static readonly object syncRoot = new object();    private SingletonSync()    &#123;     &#125;    public static SingletonSync GetInstance()    &#123;        lock (syncRoot)        &#123;            if (instance == null)                instance = new SingletonSync();        &#125;        return instance;    &#125;&#125;\n\n双重锁单例模式//上述做法有点影响性能——对每一个线程都加锁处理…，我们不用让线程每次都先加锁，而只是在实例未创建的时候再加锁处理。同时也保证了多线程安全。提供了双重锁定的方法：//双重锁定class SingletonDoubleSync&#123;    private static SingletonDoubleSync instance;    private static readonly object SyncRoot = new object();    private SingletonDoubleSync()    &#123;     &#125;    public static SingletonDoubleSync GetInstance()    &#123;        if (instance == null)        &#123;            lock (SyncRoot)            &#123;                if (instance == null)                &#123;                    instance = new SingletonDoubleSync();                &#125;            &#125;                  &#125;        return instance;    &#125;&#125;可不可以将内部的instance==null判断删除？不可以，比如说，有两个instance均为null的线程同时访问单例类，它们都可以通过第一重instance==null的检查，待第一个线程执行完后，第一个线程获取到了实例，若此时没有instance==null的内层判断，第二个线程可以紧接第一个线程后获取到实例。\n\n单例模式总结客户端不必再考虑是否需要去实例化的问题，而把责任都给了应该负责的类去处理。这涉及了设计模式中的单例模式。实例化与否的过程应该由类自身来判断，而不是别人的责任，别人只是要使用它。  \n单例模式解决的两个基本问题：全局访问和实例化控制。\n单例模式使用的场景\n需要频繁的进行创建和销毁的对象\n创建对象时耗时过多或耗费资源过多(重量级对象)\n经常用到的对象、工具类对象、频繁访问数据库或文件的对象(数据源、session工厂)\n比如说，unity设计游戏中GameManager、AudioManager\n\n如何维护单一的实例？不被外界new？所有类都有构造方法，不编码系统默认生成空的构造方法，若有显示定义的构造，则默认构造会失效。  \n只需要将构造方法变成private的，那么外部程序就不能new它了。\n那么如何调用这个单一的实例呢？书写public的方法返回类的实例，类的构造过程在类中实现。\n对唯一实例的受控访问单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎么样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。\n多线程时候的单例模式多个线程同时访问Singleton类调用GetInstance方法，会有可能造成产生多个实例。  \n可以给进程加锁Lock来处理。  \nLock是确保当一个线程位于代码段临界区时，另一个线程不进入临界区。如果其他的线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。  \n也就是说，Lock可以确保前面占用代码的一个线程先跑完，再使下一个要获取该锁的线程开始，否则下一个要跑该段代码段等待。\n饿汉式\nclass Singleton &#123;    //私有化构造器    private Singleton() &#123;        &#125;    //内部创建对象实例    private final static Singleton instance = new Singleton();    //对外公有的静态方法    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;class Singleton &#123;  //静态代码块    //私有化构造器    private Singleton() &#123;&#125;    //内部创建对象实例    private  static Singleton instance;    static &#123; // 在静态代码块中，创建单例对象        instance = new Singleton();    &#125;    //对外公有的静态方法    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;\n\n懒汉式所谓懒汉式，就是在需要调用的时候再创建类的实例。\n线程不安全的懒汉式单例class Singleton &#123; //线程不安全    private static Singleton instance;    private Singleton() &#123;&#125;    public static Singleton getInstance() &#123; //调用时才实例化对象，懒汉式        if(instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;\n\n线程安全的懒汉式单例上面线程不安全，那上锁不就好了，使用synchronized关键字。  \n这样虽然解决了线程安全，但其实实例化操作只做一次，而获取实例  \n(即getInstance)的操作是很多次的，把调用的方法加上同步，会大大降低效率。\nclass Singleton &#123; //线程安全    private static Singleton instance;    private Singleton() &#123;&#125;    //synchronized同步处理    public static synchronized Singleton getInstance() &#123;        if(instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;\n\n双重检查多线程安全单例模式上面代码效率低，那在同步前判断一下有没有实例化不就好了，若没有实例化则用同步方法new一个，否则直接return即可。即所谓的双重检查。 需要用到关键字volatile，防止指令重排。如果不用volatile关键字，就会和线程不安全情形一样，在if判断那会有并发。\nclass Singleton &#123; //双重检查    private static volatile Singleton instance;    private Singleton() &#123;&#125;    public static synchronized Singleton getInstance() &#123;        if(instance == null) &#123; //判断是否实例化            synchronized (Singleton.class) &#123;                if(instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance; //否则直接return    &#125;&#125;\n\n静态内部类单例模式实现静态内部类在外部类装载时不会实例化，当调用的时候才会装载并实例化，且JVM保证了其装载时的线程安全性。也能保证懒加载和线程安全，有点像自带版的双重检查。\nclass Singleton &#123;    private static volatile Singleton instance;    private Singleton() &#123;&#125;    //静态内部类,包含一个静态属性：Singleton    private static class SingletonInstance &#123;        private static final Singleton INSTANCE = new Singleton();     &#125;    //对外公有的静态方法，直接返回SingletonInstance.INSTANCE    public static synchronized Singleton getInstance() &#123;        return SingletonInstance.INSTANCE;    &#125;&#125;\n\n枚举实现的单例模式其实，使用枚举也能实现单例模式，不仅能避免多线程同步问题，也能防止反序列化重新创建新的对象。\nenum Singleton &#123;    INSTANCE; //属性    public void say() &#123;        System.out.println(&quot;好哎&quot;);    &#125;&#125;","categories":["--[设计模式]"],"tags":["设计模式","单例模式"]},{"title":"命令模式（Command）","url":"/2023/04/12/DesignPattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Command%EF%BC%89/","content":"命令模式（Command）命令模式（Command），将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或者记录日志，以及支持可撤销的操作。\n命令模式结构图无，以后将会重构。\n命令模式代码结构//客户端Receiver r = new Receiver();Command c = new ConcreteCommand(r);Invoker i = new Invoker();i.SetCommand(c);i.ExecuteCommand();/// 命令类，用来声明执行操作的接口abstract class Command&#123;    protected Receiver receiver;    public Command(Receiver receiver)    &#123;        this.receiver = receiver;    &#125;    abstract public void Execute();&#125;/// 具体的命令类，将一个接收者对象绑定于一个动作，调用接收者对应的操作，以实现executeclass ConcreteCommand : Command&#123;    public ConcreteCommand(Receiver receiver) : base(receiver)    &#123; &#125;    public override void Execute()    &#123;        throw new NotImplementedException();    &#125;&#125;/// 要求该命令执行这个请求&gt;class Invoker&#123;    private Command command;    public void SetCommand(Command command)    &#123;        this.command = command;    &#125;    public void ExecuteCommand()    &#123;        command.Execute();    &#125;&#125;/// 知道如何实施一个与执行一个请求有关的操作，任何类都可以成为接收者class Receiver&#123;    public void Action()    &#123;         //执行请求    &#125;&#125;\n\n命令模式总结命令模式优点：它能够较容易地设计一个命令队列；  \n在需要的情况下，可以较容易地将命令计入日志；  \n允许接收请求的一方决定是否要否决请求；  \n容易地实现对请求的撤销和重做；  \n由于加进新的具体命令类不影响其他的类，因此增加新的具体命令非常容易。  \n命令模式把请求一个操作的对象和知道如何执行操作的对象分离开。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"原型模式（Prototype）","url":"/2023/04/12/DesignPattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype%EF%BC%89/","content":"原型模式（Prototype）原型模式Prototype，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n原型模式结构图\n原型模式代码结构原型类abstract class Prototype&#123;    private string id；    public Prototype(string id)    &#123;        this.id = id;    &#125;    public string id    &#123;        get&#123;return id;&#125;    &#125;    public abstract Prototype Clone();    //--------&gt;抽象类关键就是这个Clone方法&#125;具体原型类class ConcretePrototype1 : Prototype&#123;    public ConcretePrototype1(string id) : base(id) &#123;  &#125;    public override Prototype Clone()    &#123;        return (Prototype) this.MemberwiseClone( );    &#125;    //创建当前对象的浅表副本。方法是创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段是值类型的，则对该字段执行逐位复制。如果字段是引用类型，则复制引用但不复制引用的对象；因此，原始对象及其副本引用同一对象。&#125;客户端代码ConcretePrototype1 p1 = new ConcretePrototype1(&quot;1&quot;);ConcretePrototype1 c1 = (ConcretePrototype1) p1.Clone( );Console.WriteLine(&quot;Cloned:&#123;0&#125;&quot;,c1.id);//克隆类ConcretePrototype1的对象p1就能得到新的实例c1//.Net提供了ICompareble接口，其中就是唯一的Clone方法。//继承实现这个接口就能完成原型模式了。\n\n什么时候使用原型模式呢？可以想到，每次new一次，都需要执行一次构造函数，如果构造执行花费的时间长，那么多次执行这个初始化操作实际上是非常低效的。\n一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这样既隐藏了对象创建的细节，又对性能是大大的提升。\n不用重新初始化对象，而是动态地获取对象运行时的状态。 \n拷贝对象，通过传引用，而不是传递值，这样做，相当于b，c处的均指向a处\nResume a = new Resume( );a.setWorkExperience( );a.xxx = xxx;Resume b = a;Resume c = a;\n\n通过Clone方法来创建一个副本对象。例子简历类的克隆简历类class Resume : Icloneable&#123;    private string name;    private string sex;    private string age;    private string timeArea;    private string company;    public Resume(string name)    &#123;        this.name = name;    &#125;    public void SetPersonalInfo(string sex,string age)    &#123;        this.set = sex;        this.age = age;    &#125;    public SetWorkExperience(string timeArea,string company)    &#123;        this.timeArea = timeArea;        this.company = company;    &#125;    public void Display()    &#123;        //展示自己，略    &#125;    public Object Clone( )    &#123;        return (Object) this.MemberwiseClone( );    &#125;&#125;客户端代码：    Resume a = new Resume(&quot;求职者姓名&quot;);    a.SetPersonInfo(&quot;男&quot;,&quot;19&quot;);    a.SetWorkExperience(&quot;xx&quot;,&quot;xx&quot;);    Resume b = (Resume)a.Clone( );    b.SetWorkExperience(&quot;xxx&quot;,xxx);    a.display( )    b.display( )\n\n注意！！！，上述例子只是特例，下面需要分清楚【浅表复制与深层复制】\n简历的深复制实现    Icloneable:    简历 : Iconeable    +Clone() :Object    +设置个人信息（sex:string ,age : int）    +设置工作经历（timeArea : string, company :string）    +显示( )class WorkExperience : Icloneable&#123;//工作经历类    private string workData;    public string workData    &#123;        get&#123;return workData;&#125;        set&#123;workData = value;&#125;    &#125;    private string Company;    public string Company    &#123;        get&#123;return Company;&#125;        set&#123;Company = value;&#125;    &#125;    public Object Clone()    &#123;        return (Object) this.MemberwiseClone( );    &#125;&#125;class Resume : Icloneable&#123;    private string name;    private string sex;    private string age;    private WorkExperience work;    public Resume(string name)    &#123;        this.name = name;        work = new WorkExperience( );    &#125;    private Resume(WorkExperience work)    &#123;//提供Clone方法调用的私有构造函数，以便克隆“工作经历”的数据。        this.work = (WorkExperience)work.Clone();    &#125;    //设置个人信息public void SetPersonalInfo(string sex,string age)    &#123;        this.set = sex;        this.age = age;    &#125;    //设置工作经历    public void SetWorkExperience(string workData,string company)    &#123;        work.WorkData = workData;        work.Company = company;    &#125;    //显示    public void Display( )    &#123;         //打印信息    &#125;    //调用私有的构造方法，让“工作经历”克隆完成，然后，再给这个“简历”对象的相关字段赋值，最终返回一个深复制的“简历”对象。    public Object Clone( )    &#123;         Resume obj = new Resume(this.work);        obj.name = this.name;        obj.sex = this.sex;        obj.age = this.age;        return obj;    &#125;&#125;","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"备忘录模式（Memento）","url":"/2023/04/12/DesignPattern/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88Memento%EF%BC%89/","content":"备忘录模式的定义与特点备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。  \n备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。  \n备忘录模式减少了细节的暴露  \n例如，将许多实现细节写在了客户端当中，这是相当不可取的。\n备忘录模式结构图\n备忘录模式成员分析Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复状态。Originator可根据需求决定Memento存储Originator的哪些内部状态。  \nMemento(备忘录)：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。  \nCaretaker(管理者)：负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。\n备忘录模式代码结构发起者类（Originator）Class Originator&#123;    //需要保存的属性，可以有多个    Private string state;    Public string State    &#123;    get&#123; return state; &#125;    set&#123; state = value; &#125;    &#125;    //创建备忘录，将当前需要保存的信息导入并实例化出一个Memento对象    Public Memento CreateMemento()    &#123;        Retrun new Memento(state);    &#125;    //恢复备忘录，将Memento导入并将相关数据恢复    Public SetMemento(Memento memento)    &#123;        State = memento.state;    &#125;    //public void show()    //&#123;    //展示数据    //&#125;&#125;//备忘录类Class Memento&#123;    Private string state;    //构造方法，将相关数据导入    Public Memento(string state)    &#123;        This.state = state;    &#125;    //需要保存的数据属性，可以有多个    Public string State    &#123;        get&#123; return state; &#125;    &#125;&#125;//管理者类Class Caretaker&#123;    Private Memento memento;    //设置或得到备忘录    Public Memento Memento    &#123;        get&#123; return memento; &#125;        set&#123; memento = value; &#125;    &#125;&#125;//客户端代码    Originator p = new Originator( );    p.State = &quot;On&quot;;    p.show();    //保存状态    Caretaker c = new Caretaker( );    C.memento = o.CreateMemento( );    //这隐藏了Originator的实现细节    //改变了p的状态    p.state = &quot;Off&quot;;    p.show( );    //恢复成之前的状态    c.SetMemento(c.memento);    p.show( );\n\n备忘录模式总结备忘录模式是一种对象行为型模式。\n优点：\n\n提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。\n实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。(备忘录模式将要保存的细节都封装在了Memento中，当要更改保存的细节时也不用再影响客户端了。)\n简化了 发起人 类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。\n\n缺点:\n\n资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。\n\n意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。  \n主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。  \n何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。  \n如何解决：通过一个备忘录类专门存储对象状态。关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。应用实例： \n\n后悔药。 \n\n打游戏时的存档。 \n\nWindows 里的 ctrl + z。 \n\nIE 中的后退。 \n\n数据库的事务管理。\n\n\n使用场景： \n\n需要保存/恢复数据的相关状态场景。 \n\n提供一个可回滚的操作。  \n\n\n注意事项： \n\n为了符合迪米特原则，还要增加一个管理备忘录的类。 \n\n为了节约内存，可使用原型模式+备忘录模式。\n\n\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"外观模式（Facade）","url":"/2023/04/12/DesignPattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade%EF%BC%89/","content":"外观模式（Facade）即使你没有听说过外观模式，也完全有可能在很多时候使用过它。\n外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n外观模式结构图\n外观模式代码结构四个子系统的类class SubSystemOne&#123;    public void MethodOne( )    &#123;        //do something    &#125;&#125;class SubSystemTwo&#123;    public void MethodTwo( )    &#123;        //do something    &#125;&#125;class SubSystemThree&#123;    public void MethodThree( )    &#123;        //do something    &#125;&#125;class SubSystemFour&#123;    public void MethodFour( )    &#123;        //do something    &#125;&#125;外观类它需要了解所有的子系统的方法或属性，进行组合，以备外界调用class Façade&#123;    SubSystemOne one;    SubSystemTwo two;    SubSystemThree three;    SubSystemFour four;    public Façade()    &#123;        one = new SubSystemOne( );        two = new SubSystemTwo( );        three = new SubSystemThree three;        four = new SubSystemFour four;    &#125;    public void MethodA()    &#123;//方法组A        one.MethodOne();        Three.MethodThree();    &#125;    public void MethodB()    &#123;//方法组B        two.MethodTwo();        four.MethodFour();    &#125;    ...定义更多的适合逻辑的算法方法组    &#125;客户端调用由于Facade的作用，客户端不必了解三个子系统的存在。Façade façade = new Façade();façade.MethodA();façade.MethodB();\n\n外观模式总结外观模式完美地体现了依赖倒转原则和迪米特法则的思想，所以是非常常用的模式之一。\n外观模式的结构外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。外观（Facade）模式包含以下主要角色。外观（Facade）角色：为多个子系统对外提供一个共同的接口。子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。客户（Client）角色：通过一个外观角色访问各个子系统的功能。\n如何使用外观模式？首先，在设计阶段初期，应该要有意识的将不同的两个层分离。比如说经典的三层架构，考虑在数据访问层和业务逻辑层，业务逻辑层和表示层的层与层之间建立外观Facade，这一可以为复杂的子系统提供一个简单的接口，使耦合大大降低。  \n其次，在开发阶段，子系统往往因为不断地重构演化而变得越来越复杂，大多数的模式使用也会产生许多小的类，这增加了使用上的困难。增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。  \n第三，在维护一个遗留的大型系统时，可能这个系统以及非常难以维护和拓展了，但因为它包含非常重要的功能，新的需求开发必须依赖于它。此时用外观模式Facade时非常合适的。为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。\n外观模式应用场景通常在以下情况下可以考虑使用外观模式。\n\n对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。\n当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。\n当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。\n\n外观模式优缺点外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。\n\n降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。\n对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。\n降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。\n\n外观（Facade）模式的主要缺点如下。\n\n不能很好地限制客户使用子系统类，很容易带来未知风险。\n增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。\n\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"工厂方法模式（Factory Method）","url":"/2023/04/12/DesignPattern/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Method%EF%BC%89/","content":"工厂方法模式（Factory Method）工厂方法模式（Factory Method），定义了一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。\n工厂方法模式结构图\n 例子 \n\n工厂方法模式代码结构先构建一个工厂接口 IFactoryinterface IFactory&#123;    operation CreateOperation();&#125;然后各个计算方法均各建一个具体工厂类取实现该接口class AddFactory : IFactory&#123;//加法类工厂    public operation CreateOperation()    &#123;        retrun new OperationAdd();    &#125;&#125;class SubFactory : IFactory&#123;//减法类工厂    public operation CreateOperation()    &#123;        retrun new OperationSub();    &#125;&#125;class MulFactory : IFactory&#123;//乘法类工厂    public operation CreateOperation()    &#123;        retrun new OperationMul();    &#125;&#125;class DivFactory : IFactory&#123;//除法类工厂    public operation CreateOperation()    &#123;        retrun new OperationDiv();    &#125;&#125;//客户端调用：IFactory operFactory = new AddFactory();Operation oper = operFactory.CreateOperation( );oper.NumA = 1;oper.NumB = 2;double result = oper.GetResult( );\n\n简单工厂和工厂方法模式区别所在：\n要添加功能类时简单工厂需要先添加一个功能类，再到工厂中添加注册case语句。而工厂方法需要添加一个工厂类继承工厂接口，再去更改客户端。看起来好似不但没有简化难度，反而增加了很多的类和方法，复杂度更高了。可以想到，修改简单工厂违背了“开闭原则”，而工厂方法不会。\n\n简单工厂模式最大的优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。\n\n\n工厂方法模式是为了符合“开闭原则”的精神而设计的。既然工厂类和分支耦合，那么就对它下手，  根据依赖倒置原则，将工厂类抽象出一个接口。\n这个接口只有一个方法，就是创建抽象产品的工厂方法。  \n然后所有生产具体对象的工厂，都要去实现这个接口。 \n这样——简单工厂就被拆成了一个工厂抽象接口和多个生成具体对象的工厂 \n要添加功能时，只需要增加此功能的产品类和相应的工厂类即可。\n\n可以注意到： \n工厂方法模式对于整个工厂和产品体系都没有修改的变化，只有拓展的变化。 \n工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说工厂方法把简单工厂的内部逻辑判断移到了客户端代码进行。需要加功能时，简单工厂需要改工厂类，而工厂方法需要修改客户端。\n这样还是没有避免修改客户端的弊端——“最佳做法”  \n利用“反射”可以解决避免分支判断的问题。\n游戏开发中的工厂模式——对象池(Object Pool)使用工厂模式创建对象，可以对对象进行统一的创建、初始化等操作，便于对对象做统一的管理，比如对频繁创建销毁的对象增加内存池。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"建造者模式（Builder）","url":"/2023/04/12/DesignPattern/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder%EF%BC%89/","content":"建造者模式（Builder）引言：根据依赖倒置原则，抽象不应该依赖于细节，细节应该依赖于抽象。将工作流程看作抽象的流程，具体怎么做，各个细节都依赖于这个抽象。  \n为了不让程序“缺胳膊少腿”，最好的办法是规定。  \n建造的过程是稳定的，而具体建造的什么东西、各个细节是不同的，但对于用户来说，用户不管这些内容，他只知道他想要得到什么，我们只管建造好对应的东西给用户就行。  \n如果需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。我们可以应用——“建造者模式”，又叫生成器模式(Generator)。  \n建造者模式将一个产品的内部表象与产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。用了建造者模式，只需要指定需要建造的类型就可以得到它们，而具体的建造过程和细节就不必知道了。\n建造者模式结构图\n建造者模式成员分析Director：控制者类，这是控制整个组合过程，在这个类内部有个Construct()方法，这个方法的作用就是通过调用Builder内部的各个组件的生成方法来完成组装；  \nBuilder：构建者接口，定义各部件生成的方法；  \nConcreteBuilder：具体构建者类：实现Builder构建者接口，具体定义如何生成各个部件；依赖于Product成品类，其中还有获取成品组装结构的方法GetResult()方法；  \nProduct：成品类  \n建造者模式代码结构//产品类public class Product &#123;    IList&lt;string&gt; parts = new IList&lt;string&gt;();    public void add(String part)    &#123;//添加产品部件        parts.Add(part);    &#125;    public void Show() &#123;        Console.WriteLine(&quot;产品创建——&quot;);        for (String part in parts) &#123;            //show parts        &#125;    &#125;&#125;//builder类——抽象建造者类，确定产品由两个部件组成并声明返回构建结果的方法。abstract class Builder&#123;    public abstract void  BuildPartA();    public abstract void  BuildPartB();    public abstract Product  GetBuildResult();&#125;//具体建造者类class ConcreteBuilder1 : Builder&#123;private Product product = new Product();//建造具体的两个部件public Override void BuilderPartA()&#123;product.Add(&quot;部件A&quot;);&#125;public Override void BuilderPartB()&#123;product.Add(&quot;部件B&quot;);&#125;public Override void GetBuildResult()&#123;return product;&#125;&#125;class ConcreteBuilder2 : Builder&#123;private Product product = new Product();//建造具体的两个部件public Override void BuilderPartA()&#123;product.Add(&quot;部件X&quot;);&#125;public Override void BuilderPartB()&#123;product.Add(&quot;部件Y&quot;);&#125;public Override void GetBuildResult()&#123;return product;&#125;&#125;Director类——指挥者类（中间类），用于指挥建造过程class Director&#123;    public void Construct(Builder builder)    &#123;        builder.BuildPartA();        builder.BuildPartB();        builder.GetBuildResult();    &#125;&#125;客户端代码，客户不需要知道具体的构造过程Director director = new Director( );Builder b1 = new ConcreteBuilder1( );Builder b2 = new ConcreteBuilder2( );director.Construct(b1);Product p1 = b1.GetResult( );p1.Show( );director.Construct(b2);Product p2 = b2.GetResult( );p2.Show( );\n\n建造者模式总结建造者模式（Builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n什么时候使用构造者模式呢？主要用于创建一些复杂的对象，这些对象内部构造间的顺序是稳定的，但对象内部的构造通常面临着复杂的变化时。构造者模式的好处就是使得建造代码和表示代码分离，由于建造者模式隐藏了该产品是如何组装的，所以如果需要改变一个产品的内部表示，需要新建一个具体构造类来继承抽象构造类并实现。\n建造者模式是怎么做的呢?通过抽象类来做产品的规范通过继承抽象类来实现不同产品的各个不同的构造细节通过中间类（指挥者类）来控制一致的构造过程客户不需要知道构建的细节，只需要了解两个接口——中间类（指挥者）和建造具体产品类。\n建造者模式应用场景如果我们需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们可以使用 Builder模式，又叫生成器模式。如果我们用了Builder模式，那么用户就只需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。比如现在我们有一个这样的使用场景，需要在屏幕上画小人，人要有头手脚，要画不同的人，胖的小人，瘦的小人，矮的小人。按照通常的写法，会有很多的样板代码，画人的头，画人脚手，如果一不小心，非常容易缺胳膊少腿。  \n实例1——建造复杂对象public class Person &#123;    //限于篇幅get和set方法此处省略    Head head;    Body body;    Arm leftArm;    Arm rightArm;    Leg leftLeg;    Leg rightLeg;    public void drawHead(int size)&#123;...&#125;    public void drawBody(int size)&#123;...&#125;    public void drawLeftArm(int size)&#123;...&#125;    public void drawRightArm(int size)&#123;...&#125;    public void drawLeftLeg(int size)&#123;...&#125;    public void drawRightLeg(int size)&#123;...&#125;&#125;abstract class BuilderPerson &#123;    protected Person person = new Person();    public abstract void buildHead();    public abstract void buildBody();    public abstract void buildLeftArm();    public abstract void buildRightArm();    public abstract void buildLeftLeg();    public abstract void buildRightLeg();&#125;public class BuilderThinPerson extends BuilderPerson&#123;    @Override    public void buildHead() &#123;        person.drawHead(10);    &#125;    @Override    public void buildBody() &#123;        person.drawBody(10);        //画胖小人只需将这边的数值修改，        //再生成一个类即可    &#125;    @Override    public void buildLeftArm() &#123;        person.drawLeftArm(5);    &#125;    @Override    public void buildRightArm() &#123;        person.drawRightArm(5);    &#125;    @Override    public void buildLeftLeg() &#123;        person.drawLeftLeg(7);    &#125;    @Override    public void buildRightLeg() &#123;        person.drawRightLeg(7);    &#125;&#125;我们还缺Builder模式中一个非常重要的类，指挥者(Director)，用它来控制建造过程，也用来隔离用户与建造过程的关联。public class PersonDirector&#123;    private BuilderPerson pb;    public PersonDirector(BuilderPerson pb)&#123;        this.pb = pb;    &#125;    //建造的过程在指挥者这里完成，用户就不需要知道了    public void createPerson() &#123;        pb.buildHead();        pb.buildBody();        pb.buildLeftArm();        pb.buildRightArm();        pb.buildLeftLeg();        pb.buildRightLeg();    &#125;&#125;客户端代码BuilderPerson bp = new BuilderThinPerson();PersonDirector pd = new PersonDirector(bp);pd.createPerson();\n\n实例2——复杂构造（大量可选参数拓展）遇到多个构造器参数时要考虑用构建器。静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。考虑这样的一个场景：用一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必需的：每份的含量、每罐的含量以及每份的卡路里，还有超过20个可选域:总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等。程序员一向习惯采用重叠构造器模式，在这种模式下，你提供第一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个有两个可选参数，以此类推，最后一个构造器包含所有可选参数。重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难编写，并且仍然难以阅读。一长串类型相同的参数会导致一些微妙的错误。如果客户端不小心颠倒了其中两个参数的顺序，编译器也不会出错，但是程序在运行时会出现错误的行为。\npublic class NutritionFacts &#123;    private final int servingSize;    private final int servings;    private final int calories;    private final int fat;    private final int sodium;    private final int carbohydrate;    public static class Builder &#123;        //required parameters 必须的参数表列        private final int servingSize;        private final int servings;//Optional parameters - initialized to default values  //可选的参数表列，初始化到默认值        private int calories;        private int fat;        private int sodium;        private int carbohydrate;        public Builder(int servingSize, int servings)&#123;            this.servingSize = servingSize;            this.servings = servings        &#125;        public Builder calories(int val)&#123;            calories = val;            return this;        &#125;        public Builder fat(int val)&#123;            fat = val;            return this;        &#125;        public Builder sodium(int val) &#123;            sodium = val;            return this;        &#125;        public Builder carbohydrate(int val)&#123;            carbohydrate = val;            return this;        &#125;        public NutritionFacts build() &#123;            return new NutritionFacts(this);        &#125;    &#125;    private NutritionFacts(Builder builder)&#123;        servingSize = builder.servingSize;        servings = builder.servings;        calories = builder.calories;        fat = builder.fat;        sodium = builder.sodium;        carbohydrate = builder.carbohydrate;    &#125;&#125;\n\n建造者模式优点\n建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。\n在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。\n\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"抽象工厂模式（Abstract Factory）","url":"/2023/04/12/DesignPattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Abstract-Factory%EF%BC%89/","content":"抽象工厂模式（Abstract Factory）抽象工厂模式（Abstract Factory），提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。\n抽象工厂模式结构图略，用途较少，缺点很多\n抽象工厂的优点最大的优点是：易于交互产品系列，由于具体工厂类，在一个应用中只需要在初始化时出现一次，这使得改变一个应用的具体工厂非常容易，它只需要改变具体工厂即可使用不同的产品配置。如果需要更改数据库访问，只需要更改具体工厂即可。  \n第二：它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中。（客户端只需要认识IUser和IDepartment，即数据操作的抽象接口即可）\n抽象工厂的缺点缺点是显而易见的，如果需求的更改来自于增加功能，如增加项目表  \n我们就需要多写IProject、SqlServerProject、AccessProject三个类。  \n还要更改IFactory、SqlServerFactory、AccessFactory。非常糟糕。\n实例——不同的数据库访问在数据库中的实践，在设计数据库访问底层持久时，需要考虑到底使用哪种数据库，如果一开始没有对此进行设计，碰到更换数据库时，将会是一场灾难。class Department&#123; //... &#125;    interface IDepartment    &#123;        void Insert(Department department);        Department GetDepartment(int id);    &#125;    //用于访问sqlserver的Department表    class SqlSeverDepartment : IDepartment    &#123;        public Department GetDepartment(int id)        &#123;            return null;        &#125;        public void Insert(Department department)        &#123;            //SqlSever向Department表插入一条数据        &#125;    &#125;    //用于访问Access的Department表    class AccessDepartment : IDepartment    &#123;        public Department GetDepartment(int id)        &#123;            return null;        &#125;        public void Insert(Department department)        &#123;            //Access向Department表插入一条数据        &#125;    &#125;    interface IFactory    &#123;        IUser CreateUser();        IDepartment CreateDepartment();    &#125;    class SqlServerFactory : IFactory    &#123;        public IDepartment CreateDepartment()        &#123;            //实例化Sqlserver对应的部门类            return new SqlSeverDepartment();            throw new NotImplementedException();        &#125;        public IUser CreateUser()        &#123;            //实例化Sqlserver对应的用户类            return new SqlServerUser();            throw new NotImplementedException();        &#125;    &#125;    class AccessFactory : IFactory    &#123;        public IDepartment CreateDepartment()        &#123;            //实例化Access对应的部门类            return new AccessDepartment();            throw new NotImplementedException();        &#125;        public IUser CreateUser()        &#123;            //实例化Access对应的用户类            return new AccessUser();            throw new NotImplementedException();        &#125;    &#125;    //客户端代码    class solution    &#123;        static void Main(string[] args)        &#123;            User user = new User();            Department dept = new Department();            //确定实例化哪一个数据库访问对象给factory            IFactory factory = new SqlServerFactory();            //IFactory factory = new AccessFactory();            //此时与具体的数据库访问解除了依赖            IUser iu = factory.CreateUser();            iu.Insert(dept);            iu.GetUser();            //此时与具体的数据库访问解除了依赖            IDepartment id = factory.CreateDepartment();            id.Insert(dept);            id.GetDepartment(1);        &#125;    &#125;\n\n用简单工厂方式改进抽象工厂模式去除三个类：IFactory、SqlServerFactory和AccessFactory  \n取代之用DataAccess类通过简单工厂来实现  \n改进后的抽象工厂结构图： \n\n代码实现：class DataAccess&#123;    private static readonly string db = &quot;sqlserver&quot;;    //private static readonly string db = &quot;Access&quot;;    public static IUser CreateUser()    &#123;        IUser result = null;        switch(db)        &#123;            case &quot;sqlserver&quot;:                result = new SqlServerUser();                break;            case &quot;Access&quot;:                result = new AccessUser();                break;        &#125;        return result;    &#125;    public static IDepartment CreateDepartment()    &#123;        IDepartment result = null;        switch (db)        &#123;            case &quot;sqlserver&quot;:                result = new SqlServerDept();                break;            case &quot;Access&quot;:                result = new AccessDept();                break;        &#125;        return result;    &#125;&#125;//客户端代码User user = new User();Department dept = new Department();IUser iu = DataAccess.CreateUser();iu.Insert(user);iu.GetUser(1);IDepartment id = DataAccess.CreateDepartment();id.Insert(dept);id.GetDepartment(1);如果要增加Oracle数据库访问，只需要在DataAccess类中每个方法的switch分支中添加Oracle分支。\n\n抽象工厂模式+反射（+配置）实现数据访问","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"桥接模式（Bridge）","url":"/2023/04/12/DesignPattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge%EF%BC%89/","content":"桥接模式（Bridge）桥接模式（Bridge），将抽象部分与它的实现部分分离，使它们可以独立地变化。  \n实现指的是抽象类和它的派生类用来实现自己的对象。  \n实现的方式有多种，桥接模式的思想就是把这些实现独立出来，让它们各自的变化，这样就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。  \n实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们的耦合。  \n桥接模式是合成/聚合原则的完美体现。\n桥接模式结构图\n实例\n桥接模式代码结构//桥接模式代码结构abstract class Implementor    &#123;        public abstract void Operation();    &#125;    class ConcreteImplementorA : Implementor    &#123;        public override void Operation()        &#123;            //方法A的具体实现        &#125;    &#125;    class ConcreteImplementorB : Implementor    &#123;        public override void Operation()        &#123;            //方法B的具体实现        &#125;    &#125;    class Abstraction    &#123;        protected Implementor implementor;        public void SetImplementor(Implementor implementor)        &#123;            this.implementor = implementor;        &#125;        public virtual void Operation()        &#123;            implementor.Operation();        &#125;    &#125;    class RefinedAbstraction : Abstraction    &#123;        public override void Operation()        &#123;            implementor.Operation();        &#125;    &#125;//客户端调用Abstraction ab = new RefinedAbstraction();ab.SetImplementor(new ConcreteImplementorA());ab.Operation();ab.SetImplementor(new ConcreteImplementorB());ab.Operation();","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"模板方法模式（TemplateMethod）","url":"/2023/04/12/DesignPattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88TemplateMethod%EF%BC%89/","content":"模板方法模式（TemplateMethod）当我们要完成在某一细节层次一致的一个过程或一系列步骤在更详细的层次上的实现可能不同时，我们考虑用模板方法模式来处理。  \n模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  \n总的来说，模板模式就是通过抽象类来定义一个逻辑模板，逻辑框架、逻辑原型，然后将无法决定的部分抽象成抽象类交由子类来实现，一般这些抽象类的调用逻辑还是在抽象类中完成，也就是说，算法的结构是被模板定义的。这么看来，模板就是定义一个框架，比如盖房子，我们定义一个模板：房子要封闭，有门，有窗等等，但是要什么样的门，什么样的窗，这些并不在模板中描述，这个交给子类来完善，比如门使用防盗门，窗使用北向的窗等等。\n其中基本方法一般会用final修饰，保证其不会被子类修改，而模板方法则使用protected修饰，表明其需要在子类中实现。\n其实，模板模式中还有一个钩子方法的概念，有人称，具有钩子方法的模板模式才算完整，也许吧。钩子方法时干啥的呢？钩子就是给子类一个授权，允许子类通过重写钩子方法来颠覆基本逻辑的执行，这有时候是非常有用的。\n模板方法模式结构图\n模板方法模式代码结构AbstractClass——抽象模板包含了一个模板方法，（一般为一个具体方法）给出了一个顶级逻辑的骨架，而逻辑的组成步骤是各个推迟到子类实现的抽象方法。顶级逻辑也可以调用一些具体方法。class AbstractClass&#123;    public abstract void PrimitiveOperation1( );    public abstract void PrimitiveOperation2( );    public void TemplateMethod( )    &#123;        PrimitiveOperation1( );        PrimitiveOperation2( );        //do something;    &#125;&#125;ConcreteClass，具体逻辑实现类，实现父类所定义的一个或多个抽象方法。每个AbstractClass都可以由任意多个ConcreteClass与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是这些顶级逻辑的任意组成步骤的不同实现），从而使得顶级逻辑的实现各不相同。ConcreteClassA : AbstractClass&#123;    public override void PrimitiveOperation1( )    &#123;//具体实现逻辑方法        //具体类A方法1实现    &#125;    public override void PrimitiveOperation2( )    &#123;//具体实现逻辑方法        //具体类A方法2实现    &#125;&#125;ConcreteClassB : AbstractClass&#123;    public override void PrimitiveOperation1( )    &#123;//具体实现逻辑方法        //具体类B方法1实现    &#125;    public override void PrimitiveOperation2( )    &#123;//具体实现逻辑方法        //具体类B方法2实现    &#125;&#125;客户端调用    AbstractClass c;    c = new AbstractClassA( );    c.TemplateMethod( );    c = new AbstractClassB( );    c.TemplateMethod( );\n\n模板方法模式例子——建房子public abstract class HouseTemplate &#123;    protected HouseTemplate(String name)&#123;        this.name = name;    &#125;    protected String name;    protected abstract void buildDoor();//建门    protected abstract void buildWindow();//建窗户    protected abstract void buildWall();//建承重    protected abstract void buildBase();//建地基    protected abstract void buildToilet();//建厕所    //钩子方法    protected boolean isBuildToilet()&#123;        return true;    &#125;    //公共逻辑    public final void buildHouse()&#123;//调用顺序确定        buildBase();        buildWall();        buildDoor();        buildWindow();        if(isBuildToilet())&#123;            buildToilet();        &#125;    &#125;&#125;public class HouseOne extends HouseTemplate &#123;    HouseOne(String name)&#123;        super(name);    &#125;    HouseOne(String name, boolean isBuildToilet)&#123;        this(name);        this.isBuildToilet = isBuildToilet;    &#125;    public boolean isBuildToilet;    @Override    protected void buildDoor() &#123;        System.out.println(name +&quot;的门要采用防盗门&quot;);    &#125;    @Override    protected void buildWindow() &#123;        System.out.println(name + &quot;的窗户要面向北方&quot;);    &#125;    @Override    protected void buildWall() &#123;        System.out.println(name + &quot;的墙使用大理石建造&quot;);    &#125;    @Override    protected void buildBase() &#123;        System.out.println(name + &quot;的地基使用钢铁地基&quot;);    &#125;    @Override    protected void buildToilet() &#123;        System.out.println(name + &quot;的厕所建在东南角&quot;);    &#125;    //重写钩子方法    @Override    protected boolean isBuildToilet()&#123;        return isBuildToilet;    &#125;&#125;public class HouseTwo extends HouseTemplate &#123;    HouseTwo(String name)&#123;        super(name);    &#125;    @Override    protected void buildDoor() &#123;        System.out.println(name + &quot;的门采用木门&quot;);    &#125;    @Override    protected void buildWindow() &#123;        System.out.println(name + &quot;的窗户要向南&quot;);    &#125;    @Override    protected void buildWall() &#123;        System.out.println(name + &quot;的墙使用玻璃制造&quot;);    &#125;    @Override    protected void buildBase() &#123;        System.out.println(name + &quot;的地基使用花岗岩&quot;);    &#125;    @Override    protected void buildToilet() &#123;        System.out.println(name + &quot;的厕所建在西北角&quot;);    &#125;&#125;//测试类public class Clienter &#123;    public static void main(String[] args)&#123;        HouseTemplate houseOne = new HouseOne(&quot;房子1&quot;, false);        HouseTemplate houseTwo = new HouseTwo(&quot;房子2&quot;);        houseOne.buildHouse();        houseTwo.buildHouse();    &#125;&#125;测试结果：房子1的地基使用钢铁地基房子1的墙使用大理石建造房子1的门要采用防盗门房子1的窗户要面向北方房子2的地基使用花岗岩房子2的墙使用玻璃制造房子2的门采用木门房子2的窗户要向南房子2的厕所建在西北角\n\n模板方法总结\n使用抽象类定义模板类，并在其中定义所有的基本方法、模板方法，钩子方法，不限数量，以实现功能逻辑为主。其中基本方法使用final修饰，其中要调用基本方法和钩子方法，基本方法和钩子方法可以使用protected修饰，表明可被子类修改。  \n\n定义实现抽象类的子类，重写其中的模板方法，甚至钩子方法，完善具体的逻辑。\n\n\n模板方法使用场景\n在多个子类中拥有相同的方法，而且逻辑相同时，可以将这些方法抽出来放到一个模板抽象类中。 \n\n程序主框架相同，细节不同的情况下，也可以使用模板方法。\n\n\n模板方法模式的优势\n模板方法是通过把不变行为搬移到超类，去除子类中的重复代码来体现他的优势。  \n\n模板方法模式就是提供了一个很好的代码复用平台。  \n\n当不变的和可变的行为在方法的子类实现中混合在一起，不变的行为就会在子类中重复的出现，通过模板方法模式，可以将这些行为搬移到单一的地方，帮助这些子类摆脱重复的不变行为。\n\n\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"状态模式（State）","url":"/2023/04/12/DesignPattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88State%EF%BC%89/","content":"状态模式（State）坏的代码——冗长，难读，判断分支过多\n如何避免一个程序中写满了if和else分支判断呢？\n如果一个程序的判断分支过多时，代表着该程序的责任过多了，无论任何状态的改变，都通过它单独来改变，这是糟糕的。\n面向对象设计其实就是希望做到代码的责任分解。\n当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。  \n状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。\n状态模式结构图\n状态模式成员分析Context上下文对象，该类维护一个ConcreteState子类的实例，表示当前的状态。State抽象状态类，定义一个接口封装与Context特定状态相关的行为。ConcreteState具体状态类，每一个子类实现一个与Context中一个状态相关的行为。\n状态模式代码结构代码实现：abstract class State&#123;    public abstract void Handle(Context context);&#125;class ConcreteState1 : State&#123;    public override void Handle(Context context)    &#123;        context.State = new ConcreteStateB();    &#125;&#125;class ConcreteStateB : State&#123;    public override void Handle(Context context)    &#123;//设置下一个状态为ConcreteState1        context.State = new ConcreteState1();    &#125;&#125;class Context&#123;    private State state;//定义一个状态的引用表示当前状态    public Context(State state)    &#123;        //构造方法初始化当前状态        this.state = state;    &#125;    public State State    &#123;//可读写的状态属性，用于读取当前状态和设置新状态        get &#123; return state; &#125;        set &#123; state = value; &#125;    &#125;    public void Request()    &#123;//对请求作处理，设置下一状态。        state.Handle(this);    &#125;&#125;//客户端代码Context context = new Context(new ConcreteState1());context.Request();context.Request();context.Request();context.Request();//不断请求，context对象处理请求并更新状态\n\n经典用例——游戏中敌人aiusing System.Collections;using System.Collections.Generic;using UnityEngine;public interface Istate&#123;    public void OnStateEnter();    public void OnStateProcess();    public void OnStateExit();&#125;\n\nusing System.Collections;using System.Collections.Generic;using UnityEngine;public class States&#123;&#125;public class AlienIdle : Istate&#123;    private StateManager stateManager;    public float time;    public AlienIdle(StateManager stateManager)    &#123;        this.stateManager = stateManager;    &#125;    public void OnStateEnter()    &#123;    &#125;    public void OnStateExit()    &#123;    &#125;    public void OnStateProcess()    &#123;        Vector3 tarPos = stateManager.GetPlayerPos();        if ((tarPos - stateManager.transform.position).magnitude &lt; 8.0f)        &#123;            Debug.Log(&quot;切换到walk状态&quot;);            stateManager.ChangeState(stateType.walk);        &#125;    &#125;&#125;public class AlienWalk : Istate&#123;    private StateManager stateManager;    private float timer;    private int direction;    public AlienWalk(StateManager stateMachine)    &#123;        this.stateManager = stateMachine;    &#125;    public void OnStateEnter()    &#123;        //stateMachine._aiAnim.Play(&quot;walk&quot;);        stateManager._aiAnim.SetBool(&quot;walking&quot;,true);        if (stateManager.GetPlayerPos().x &gt; stateManager.transform.position.x)        &#123;            direction = 1;        &#125;        else        &#123;            direction = -1;        &#125;        Debug.Log(&quot;进入了Walk状态&quot;);        timer = 1.0f;    &#125;    public void OnStateExit()    &#123;        stateManager._aiAnim.SetBool(&quot;walking&quot;, false);    &#125;    public void OnStateProcess()    &#123;        stateManager._aiRigid.velocity = new Vector2(direction*stateManager.speed,0);        timer -= Time.deltaTime;        if (timer &lt; 0)        &#123;            stateManager.ChangeState(stateType.idle);        &#125;    &#125;&#125;\n\nusing System.Collections;using System.Collections.Generic;using UnityEngine;public enum stateType&#123;    idle,    walk&#125;public class StateManager : MonoBehaviour&#123;    public Animator _aiAnim;    public Rigidbody2D _aiRigid;    public Collider2D _aiCollider;    public float speed = 2.0f;    public Istate _currentState;//当前状态    public stateType _state;    public Dictionary&lt;stateType, Istate&gt; _stateMapping = new Dictionary&lt;stateType, Istate&gt;();//存放状态与枚举之间的映射值    private void Awake()    &#123;        //为状态枚举注册对应的状态        _stateMapping.Add(stateType.idle, new AlienIdle(this));        _stateMapping.Add(stateType.walk, new AlienWalk(this));        //获取对应的组件和必要参数        _aiAnim = GetComponentInChildren&lt;Animator&gt;();        _aiRigid = GetComponent&lt;Rigidbody2D&gt;();        _aiCollider = GetComponent&lt;Collider2D&gt;();        _currentState = _stateMapping[stateType.idle];    &#125;    private void Update()    &#123;        _currentState.OnStateProcess();//调用处于状态中的处理函数        Filp();    &#125;    public void ChangeState(stateType state)//切换到新的状态    &#123;        if (_currentState != null)        &#123;            _currentState.OnStateExit();        &#125;        _currentState = _stateMapping[state];        _currentState.OnStateEnter();    &#125;    #region 公用方法    //获取玩家位置    public Vector3 GetPlayerPos()    &#123;        return PlayerController.Instance().transform.position;    &#125;    //使得角色正确翻转    public void Filp()    &#123;        if (_aiRigid.velocity.x &gt; .1f)        &#123;            transform.localScale = new Vector3(-1,1,1);        &#125;else if (_aiRigid.velocity.x &lt; -.1f)        &#123;            transform.localScale = new Vector3(1, 1, 1);        &#125;    &#125;    #endregion&#125;\n\n状态模式的好处\n将特定状态相关的行为局部化，并将不同状态的行为分割开来。\n将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于ConcreteState中，所有通过定义新的子类可以很方便地增加新的状态和转换。\n消除了庞大的条件分支语句\n状态模式将各种状态转换的逻辑分布到State的子类之间，来减少相互间的依赖。\n\n什么时候考虑用状态模式？当一个对象的行为取决于他的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式。  \n枚举与状态模式+字典，天生一对。\nenum StateType&#123;    idle,    patrol,    atk,&#125;","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"简单工厂模式（SimpleFactory）","url":"/2023/04/12/DesignPattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88SimpleFactory%EF%BC%89/","content":"简单工厂模式（SimpleFactory）1、一开始：业务逻辑和客户端逻辑未分离\n2、业务的封装——实现业务和客户端界面逻辑分离\n（降低耦合度、分开来更加容易维护/拓展）\nOperation类\n客户端——mian函数\n3、更加松的耦合——通过继承运算类来实现运算的一些基本操作，将每一个运算均单独作一个新类，再实现每一个类的具体逻辑、重写一定的运算操作。如果后面要添加新的运算类，比如说开平方的运算等，可以直接建新类去继承运算类去实现。这样设计的话（松耦合），就不会影响到之前已经写好的东西。如果要对某种运算做修改，对实现该类的运算做修改即可。（设计了相当多的计算类）\n4、简单工厂模式—&gt;如何让计算器知道我要用哪一个类呢？\n使用简单工厂模式解决的问题——到底要实例化谁？如何去实例化？\n考虑到用单独的类来做这个创造实例的过程——简单工厂模式\nPublic class OperationFactory&#123;    public static Operation createFactory(string operate)    &#123;        Operation oper = null;        switch(operate)        &#123;            case :&quot;+&quot;: &#123;oper = new OperationAdd( ); break;&#125;            case:&quot;  &quot;:&#123;  … &#125;            case:&quot;  &quot;:&#123;  … &#125;            //拓展其他的功能类之后，需要在此处添加分支来提供实例化该功能类的入口。        &#125;        return oper;    &#125;&#125;class OperationAdd&#123;&#125;class xxx&#123;&#125;客户端使用工厂实例实例化对应功能类对象，再通过该实例进行计算操作。Operation oper;oper = OperationFactory.createFactory(&quot;+&quot;);oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult( );\n\n\n使用简单工厂的好处：\n做修改时，只针对某一个需要修改的功能类作修改即可，不会影响到其他的类的功能实现；\n在添加新的功能时，只需要添加对应的功能类的实现，以及在switch中添加分支即可。\n\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"类和策略模式（strategy）","url":"/2023/04/12/DesignPattern/%E7%B1%BB%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88strategy%EF%BC%89/","content":"策略模式封装了变化面向对象编程——并非类越多越好，不至于每一个功能的实现都写一个具体的类，而是抽象出他们之间的共性，类的划分是为了封装，但是分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。\n策略模式解析：策略模式是一种定义一系列算法的方法，从概念上面来看，所有的算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少各种算法类与使用算法类之间的耦合。  \n\n策略模式优点：\nStrategy类层次为Context定义了一系列的可供重用的算法和行为。继承有助于析取出这些算法中的公用功能。（例如CashContext中的GetResult来自于CashSuper）\n\n策略模式的优点就是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口独立测试。 (哪个算法出了问题，只需要修改对应的算法即可。)\n\n当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。\n\n策略模式避免了过多条件判断（if-else）语句的使用 \n\n\n策略模式是怎么避免过多的条件判断的？\n策略模式就是用来封装算法的，但在实践当中，我们发现它可以用它来封装几乎任何类型的规则，只要在分析过程中知道需要在不同时间（不同应用场合）应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。 \n\n基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context上下文对象。  \n\n在结合了工厂和策略模式后，选择所用具体实现的职责也可以由Context承担，最大化减轻了客户端的职责。  \n\n要增加一种算法的话，还是需要增加Context对象中的switch分支  \n\n但是——无论如何，任何需求的变更都是需要成本的。  \n\n只是成本开销大小的关系，面对同样的需求当然成本开销越小越好。  \n\n还提到一种反射技术——策略模式的改进\n\n\n封装变化点的思想——Context上下文对象，通过使不同算法实现类继承同一个父类，创建该父类的一个引用来装载子类对象（父类可以装子类——就比如说Object对象可以装载所有的对象），通过这个父类的引用去调用不同子类中的算法实现。\n主要的问题：怎么装载子类？——通过子类继承同一个父对象，创建一个父对象的引用来装载。怎么装载不同的子类？——通过构造方法传入不同策略对象来构造对不同子类的引用。怎么调用子类的方法？——子类通过继承override重写父类中的方法，然后通过父类的引用（这时候装载了子类）直接调用该方法即可。\n实例：商场打折促销、满减促销等不同营销策略的实现——结合CashFactory——收费工厂类商场打折促销、满减促销等不同营销策略的实现——    CashSuper——父类    CashNormal——算法1对应一个策略：常规收费    CashRebate——算法2对应一个策略：打折收费    CashReturn——算法3对应一个策略：满返收费    CashContext——收费上下文    ///        可以在此继续拓展其他的策略类    ///    public class CashContext&#123;        private CashSuper cs;//创建父类对象的引用        public CashContext(CashSuper csuper)//通过传入具体的收费策略        &#123;            this.cs = csuper;        &#125;        public double GetResult(double money)        &#123;            return cs.AcceptCash(money);        &#125;    &#125;结合CashFactory——收费工厂类    public static CashSuper createCashAccept(string type)    &#123;        CashSuper cs = null;        switch (type)        &#123;            case &quot;常规收费&quot;:&#123; cs = new CashNormal( ); break;&#125;            case &quot;打折收费&quot;:&#123; cs1 = new CashRebate( 0.8);break; &#125;            /*打折力度0.8*/             case……            //根据type传入不同的收费策略实例化不同分支收费算法类        &#125;        return cs;    &#125;客户端代码(main函数)    CashContext cc=null;    switch(int num)    &#123;        case 0:&#123;         cc = new CashContext( new CashNormal ( ) ) ;            break;        &#125;        case 1:&#123;        cc = new CashContext( new CashRebate( 0.8 ) ) ;            break;        &#125;        …    &#125;    double total=0f;    total += cc.GetResult();    …可以发现——客户端中又多了这个switch判断的过程，将它转移是可以做到的——简单工厂不一定要是单独的一个类，它可以和策略模式的Context上下文对象结合。\n\n结合简单工厂和策略模式——修改后的CashContext结合简单工厂和策略模式——修改后的CashContextclass CashContext&#123;    CashContext cc=null;    public CashContext(string type)//注意参数类型    &#123;        switch(type)        &#123;            case:&quot;常规收费&quot;:&#123;             cc = new CashContext( new CashNormal ( ) ) ;                break;            &#125;            case:&quot;打折收费&quot;:&#123;            cc = new CashContext( new CashRebate( 0.8 ) ) ;                break;            &#125;            …        &#125;    &#125;    public double GetResult(double money)    &#123;        return cs.acceptCash(money);    &#125;&#125;\n\n看看两种方式调用的区别：//用工厂方式CashSuper csuper = CashFactory.createFactory(string type);//工厂和策略模式的结合CashContext cashContext = new CashContext(string type);\n结合工厂模式与策略模式的好处：用工厂方式需要了解两个类对象CashSuper和CashFactory用工厂和策略模式结合可以只了解上下文对象CashContext这使得具体的收费算法彻底地与客户端分离，连算法的父类CashSuper都不对客户端开放。\n策略模式的思想：\n定义算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响使用该算法的客户。\n算法本身只是一种策略，最重要的是这些算法是随时可能互相替换的，这就是变化点，而封装变化点是我们面向对象的一种很重要的思维方式。\n\n策略模式标准实现抽象算法类，Strategy策略A继承自抽象算法（Strategy），ConcreteStrategyA策略B继承自抽象算法（Strategy），ConcreteStrategyB……上下文对象，Context，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。\n抽象算法类    abstract class Strategy    &#123;//算法方法        void abstract void AlgorithmInterface();    &#125;//策略A——封装了具体的算法及行为，继承于Strategy    class ConcreteStrategyA : Strategy    &#123;        public override void AlgorithmInterface()        &#123;            //具体实现        &#125;    &#125;//策略B——封装了具体的算法及行为，继承于Strategy    class ConcreteStrategyB : Strategy    &#123;        public override void AlgorithmInterface()        &#123;            //具体实现        &#125;    &#125;//上下文——Context,用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。    class Context    &#123;        Strategy strategy;        public Context(Strategy strategy)        &#123;            this.strategy = strategy;        &#125;        public void ContextInterface()        &#123;            strategy.AlgorithmInterface();        &#125;    &#125;客户端代码(main函数)：    Context context;    context = new Context(new ConcreteStrategyA( ));    context.ContextInterface( );//调用了策略A的算法实现    context = new Context(new ConcreteStrategyB( ));    context.ContextInterface( );//调用了策略B的算法实现\n\n客户端是如何调用不同的算法的：实例化了上下文对象，传入了继承Strategy类的ConcreteStrategyA类实例化的对象来初始化Context对象中的Strategy参数，此时使用的便是具体实现策略A的算法。调用Context对象的方法，即是调用策略A的方法实现，策略模式就是通过这样的上下文对象封装了“变化点”，每次采取不同的策略，就传入不同的继承自策略类Strategy的具体策略的实例即可。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"组合模式（Composite）","url":"/2023/04/12/DesignPattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite%EF%BC%89/","content":"组合模式（Composite）如果将总公司当作一颗大树的根部的话，那么对于它的下属分公司其实是这棵树的分支，至于其他更小的职能部门，则是更小处的分支以至树叶。 \n组合模式（Composite），将对象组合成树形结构以表示“部分-整体”的结构层次。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n组合模式结构图\n组合模式成员分析Component——组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件。  \nComposite——定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，例如增加Add和删除Remove。  \nLeaf——定义叶子节点行为，在组合中表示叶节点对象，叶节点没有子节点。叶子节点实现Add和Remove接口没有任何意义，因为它们没法再添加分支和树叶。实现它们可以消除叶节点和枝节点对象在抽象层次的区别，使它们具备一样的接口。\n组合模式代码结构组合模式代码结构：    /// &lt;summary&gt;    /// Component为组合中的对象声明接口，在适当情况下，    /// 实现所有类共有接口的默认行为。    /// 声明一个接口用于访问和管理Component的子部件    /// &lt;/summary&gt;    abstract class Component    &#123;        protected string name;        public Component(string name)        &#123; this.name = name; &#125;        public abstract void Add(Component c);        public abstract void Remove(Component c);        //通常用Add和Remove两方法来提供增加或移除树叶的办法        public abstract void Display(int depth);    &#125;    /// &lt;summary&gt;    /// Leaf表示叶节点对象，叶节点没有子节点    /// &lt;/summary&gt;    class Leaf : Component    &#123;        public Leaf(string name) : base(name) &#123; &#125;        public override void Add(Component c)        &#123;    //叶子节点实现Add和Remove接口没有任何意义，因为它们没法再添加分支和树叶。    //实现它们可以消除叶节点和枝节点对象在抽象层次的区别，使它们具备一样的接口。            throw new ArgumentException(&quot;叶节点无法增加分支&quot;);        &#125;        public override void Remove(Component c)        &#123;            throw new ArgumentException(&quot;叶节点没有子节点，不能移除其子节点&quot;);        &#125;        /// &lt;summary&gt;        /// 叶子的具体方法，此次提供一个展示深度和名字的方法。        /// &lt;/summary&gt;        /// &lt;param name=&quot;depth&quot;&gt;&lt;/param&gt;        public override void Display(int depth)        &#123;            Console.WriteLine(new string(&#x27;-&#x27;,depth) + name);        &#125;    &#125;    /// &lt;summary&gt;    /// Composite对象定义枝节点行为，用来存储子部件，    /// 在Component接口中实现有关与子部件的操作，    /// 比如增加Add和删除Remove    /// &lt;/summary&gt;    class Composite : Component    &#123;        //声明一个子节点集合用来存储其下属的枝节点和叶节点。        private List&lt;Component&gt;children = new List&lt;Component&gt;();        public Composite(string name) : base(name) &#123; &#125;        public override void Add(Component c)        &#123;            children.Add(c);        &#125;        public override void Display(int depth)        &#123;            Console.WriteLine(new string(&#x27;-&#x27;, depth) + name);            foreach (Component component in children)            &#123;                component.Display(depth + 2);            &#125;        &#125;        public override void Remove(Component c)        &#123;            children.Remove(c);        &#125;    &#125;客户端代码    //生成树根root    Component root = new Composite(&quot;root&quot;);    //为树根添加一个树叶    root.Add(new Leaf(&quot;Leaf A&quot;));    //为树根添加一个节点    Composite composite1 = new Composite(&quot;Composite X&quot;);    root.Add(composite1);    //为分支节点添加叶节点和分支节点    composite1.Add(new Leaf(&quot;Leaf B&quot;));    Composite composite2 = new Composite(&quot;Composite Y&quot;);    composite1.Add(composite2);    root.Display(1);    Console.Read();\n\n运行结果\n\n组合模式总结为了使整体和部分能够被一致对待，可以采用组合模式\n有一个问题——为什么树叶Leaf中也有Add和Remove呢？透明方式，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add和Remove等。这样实现Component接口的所有子对象都具备了Add和Remove等。这样使得叶节点和根节点对于外界没有区别，它们具备一致的行为接口。问题是：实现叶节点的Add和Remove是没有意义的。安全方式，也就是在Component不提供Add和Remove接口方法，那么子类的Leaf也就不需要实现它，而是在Composite声明所有用来管理子类的方法。这样就导致了不够透明，所有树叶类和树枝类将不具备相同的接口，客户端的调用需要做相应的判断，带来了不便。\n何时使用组合模式？当发现需求中是体现部分与整体层次的结构时，你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑使用组合模式。\n使用组合模式有何好处？\n组合模式定义包含了基本对象和组合对象的类层次结构。\n基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何使用到基本对象的地方都可以使用组合对象了。\n用户不用关心到底是处理一个叶节点还是处理一个组合部件，也就用不着定义组合而写一些选择判断语句了。\n组合模式使得用户可以一致地使用组合结构和单个对象。\n\n用到游戏开发中就是组件模式组件模式是将独立的功能点做一个封装，便于增删和管理。  \n组件模式一般有两种，一种就是组合(就是经常拿来跟继承对比)，另一种是属性扩展，就是将组件中的所有方法和属性，扩展到载体中。  \n例如，寻路组件，刚体组件等。  \nUnity中各种的Component就是组件，Unity就是组件的集合。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"装饰模式（Decorator）","url":"/2023/04/12/DesignPattern/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator%EF%BC%89/","content":"装饰模式（Decorator）装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。\n装饰模式结构图\nComponent是定义一个对象接口，可以给这些对象动态地添加职责。ConcentrateComponent是定义了一个具体的对象，也可以给这个对象添加职责。Decorator，装饰抽象类，继承了Component，从外类来拓展Component类的功能，但对于Component来说，是无需了解Decorator的存在的。ConcentrateDecorator类就是具体的装饰对象，起到给Component添加职责的功能。\n装饰模式代码结构Component类abstract class Component（）&#123;    public abstract void Operation（）；&#125;ConcentrateComponent类class ConcentrateComponent：Component&#123;    public override void Operation（）    &#123;        //具体对象的操作    &#125;&#125;Dectorator类Class Dectorator : Component&#123;    protected Component component;    public void setComponent(Component component)    &#123;//设置Component        this.component = component;    &#125;    public override void Operation( )    &#123;        if(component!=null)        &#123;            component.Operation( );        &#125;    &#125;&#125;ConcentrateDecoratorA类class ConcentrateDecoratorA : Decrator&#123;    public override void Operation( )    &#123;        base.Operation( );        //首先运行Component的Operation，        //再执行本类功能，相当于对Component添加了装饰        addedState = &quot;newState&quot;;        //扩展逻辑——在原有的操作上面    &#125;&#125;ConcentrateDecoratorB类class ConcentrateDecoratorB : Decrator&#123;    public override void Operation( )    &#123;        base.Operation( );         AddBehaviour( );    &#125;    public void AddBehaviour( )    &#123;        //do sthing    &#125;&#125;//主函数中调用//Dectorator dectorator = new Dectorator( );//和Component一样是不用知道它的存在的ConcentrateDecoratorA d1 = new ConcentrateDecoratorA();ConcentrateDecoratorB d2 = new ConcentrateDecoratorB();ConcentrateComponent cc = new ConcentrateComponent( );cc.setComponent(d1);d1.setComponent(d2);d2.Operation( );\n\n装饰的方法是：首先用ConcentrateComponent实例化对象cc，然后用ConcentrateDecoratorA实例化对象d1来包装cc，再用ConcentrateDecoratorB实例化对象d2来包装d1，最终执行d2的Operation（）；最终所有的Operation都会被执行，相当于在Component外拓展了功能。\n装饰模式中装饰类的顺序：装饰模式是利用SetComponent来对对象进行包装的，这样，每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链里面。完全可以调换调用的顺序。  \n如果只有一个ConcentrateComponent类而没有抽象的Component类，那么Dectorator类可以是ConcentrateComponent的一个子类。同理，如果只有一个ConcentrateDecorator类，无需单独建立一个单独的Decorator类，而把Decorator和ConcentrateDecorator的责任合并成一个类。\n问题和总结装饰模式是为已有功能动态地添加更多功能的一种方式。\n什么时候用装饰模式呢？在起初的设计中，当系统需要新功能时，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为。这种设计的问题在于，它们在主类中添加了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度。当新加入的东西只是为了满足某些方面特定情况下采用的特殊行为的需要时，可以用装饰模式将要装饰的功能放在单独的类中，让这个类包装它要装饰的对象，因此，当需要执行特殊行为时，客户端代码就可以在运行时根据需求选择性地、按顺序地使用装饰功能包装对象。\n装饰模式优点把类中的装饰功能能类中搬移去除，这样可以简化原有的类。有效地把类的核心职责和装饰功能区分开了。而且可以去除其中重复的装饰逻辑。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"观察者模式（Observer）","url":"/2023/04/12/DesignPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer%EF%BC%89/","content":"观察者模式（Observer）发布-订阅模式（Publish/Subscribe）观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当这个主题对象状态发生改变时，会通知所有的观察者对象，使他们能够自动更新自己。所以也称之为发布-订阅模式（Publish/Subscribe）。\n观察者模式结构图\n观察者模式成员分析Subject类，主题类，通常用一个抽象类或者抽象接口实现。他把所有对观察者对象的引用保存在一个聚集内。  \nobserver类,观察者类,为所有具体的观察者定义一个接口,在得到主题的通知时更新自己。ConcreteSubject，具体主题类,存入有关状态到具体观察者对象,在具体主题内部状态发生改变时,给所有登记的观察者发出通知.  \nConcreteObserver，具体观察者，在得到主题的通知时更新自己。\n观察者模式代码结构//Subject类，主题类，通常用一个抽象类或者抽象接口实现。他把所有对观察者对象的引用保存在一个聚集内。abstract class Subject&#123;    private Ilist&lt;Observer&gt; observers = new  List&lt;Observer&gt;（）；        //增加观察者        public void Attach（Observer observer）    &#123;        observer.Add(observer);    &#125;    //移除观察者    public void Detach（Observer observer）    &#123;        observer.Remove();    &#125;    //通知    public void Notify( )    &#123;        foreach(Observer o in observers)        &#123;            o.Update();        &#125;    &#125;&#125;//observer类,观察者类,为所有具体的观察者定义一个接口,在得到主题的通知时更新自己abstract class observer()&#123;    public abstract void Update();&#125;//具体主题类,存入有关状态到具体观察者对象,在具体主题内部状态发生改变时,给所有登记的观察者发出通知.class ConCreteSubject : Subject&#123;    private string subjectState;//具体被观察者的状态    public string SubjectState    &#123;        get&#123;return subjectState;&#125;        set&#123;subjectState = value;&#125;    &#125;&#125;//具体观察者class ConcreteObserver :Observer&#123;    private string name;    private striing observerState;    private ConcreteSubject subject;    public ConcreteObserver(ConserverSubject subject,string name)    &#123;        this.name = name;        this.subject = subject;    &#125;    public override void Update()    &#123;        observerState = subject.SubjectState;        //新状态是:    &#125;    public ConcreteSubject Subject    &#123;        get&#123;return subjectState;&#125;        set&#123;subjectState = value;&#125;    &#125;&#125;客户端代码ConcreteSubject s = new ConcreteSubject();s.Attach(new ConcreteObserver(s,&quot;X&quot;));s.Attach(new ConcreteObserver(s,&quot;Y&quot;));s.SubjectState = &quot;newState&quot;;s.Notify( );\n\n观察者模式总结观察者模式的核心思想是利用依赖倒置原则来解耦，通过抽象出主题类和观察者类两个类的抽象接口，来实现主题类一通知，观察者就随之改变状态。\n用在哪里？当将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是要维护相关对象的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、拓展和重用都带来不便。\n关键对象——Subject和Observer\nSubject对象不必知道具体哪个Observer，一旦发生改变，Subject将通知所有Observer。    Observer不必知道他自身具体的通知者，也不需要知道其他Observer的存在。\n这样使得程序不再紧密耦合。\n什么时候使用？一般用于一个对象改变需要同时改变其他对象时，而且它不知道具体由多少个对象有待改变时，应该考虑使用观察者模式。\n不足：一个是，抽象的通知者还是依赖于抽象的观察者，如果没有这个抽象观察者接口，这个通知的接口功能就不能完成。\n另一个是，对于每一个具体的观察者，不一定都是同样的“Update”方法的调用。\n如果通知者和观察者之间根本就互相不知道，由客户端来决定通知谁，该如何实现？\nC#观察者模式的委托实现委托实现：    首先——两个观察者类Observer将Update更名为具体的方法Method1、Method2    第二——抽象通知者不希望依赖于抽象观察者，所有关于“增减”观察者的方法不被需要，删去。interface Subject&#123;    void Notify();    string SubjectState&#123;get;set;&#125;&#125;    第三——为具体通知者声明委托delegate void EventHandler();class Notifier1 : Subject&#123;public event EventHandler Update;//声明一个&quot;EventHandler（事件处理程序）&quot;的委托事件，//名称叫Updateprivate string action;public void Notify()&#123;//在访问通知方法时，调用委托Update“更新”Update( );&#125;public string SubjectState&#123;get&#123;return action;&#125;set&#123;action = value;&#125;&#125;&#125;class Notifier2 : Subject&#123;//同上类似&#125;客户端:Notifier1 ner = new Notifier1( );ConcreteObserver1 zxf = new  ConcreteObserver1(&quot;zxf&quot;,ner);ConcreteObserver1 hyx = new  ConcreteObserver1(&quot;hyx&quot;,ner);ner.Update +=new EventHandler(zxf.Method1);ner.Update +=new EventHandler(hyx.Method2);//将具体观察者类的方法挂在通知者的Update方法上，也就是将两类不同的方法委托给了通知者类的Update。ner.SubjectState = &quot;xxx&quot;;ner.Notify( );\n\n映射到游戏开发里面就是事件、广播等的实现","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"解释器模式（Interpreter）","url":"/2023/04/12/DesignPattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Interpreter%EF%BC%89/","content":"解释器模式（Interpreter）为什么需要这种模式？\n某些场景，需要用到字符解析、SQL解析、符号处理等。\n解释器模式提供了评估语言的语法或表达式的方法。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"责任链模式（Chain_Of_Responsibility）","url":"/2023/04/12/DesignPattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Chain-Of-Responsibility%EF%BC%89/","content":"责任链模式（Chain_Of_Responsibility）职责链模式(Chain Of Responsibility),使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 \n类似于异常处理机制中定义的那样，代码抛出一个异常，在异常处理链当中，会有一个对象来处理该异常。\n职责链模式结构图\n责任链模式代码结构\n//客户端Handler h1 = new ConcreteHandler1();Handler h2 = new ConcreteHandler2();Handler h3 = new ConcreteHandler3();h1.SetSuccessor(h2);h2.SetSuccessor(h3);int[] requests = &#123; 2,3,5,6,32,57,5,21 &#125;;foreach(int request in requests)&#123;      h1.HandleRequest(request);&#125;    /// Handler类，定义一个处理请示的接口    abstract class Handler    &#123;        protected Handler successor;        //设置继任者        public void SetSuccessor(Handler successor)        &#123;            this.successor = successor;        &#125;        //处理请求的抽象方法        public abstract void HandleRequest(int request);    &#125;    /// ConcreteHandler类，具体处理者类，处理它所负责的请求，    /// 可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者    class ConcreteHandler1 : Handler    &#123;        public override void HandleRequest(int request)        &#123;            if (request &gt;= 0 &amp;&amp; request &lt; 10)            &#123;                Console.WriteLine(&quot;处理请求&quot;, this.GetType().Name, request);            &#125;            else if(successor!=null)&#123;                successor.HandleRequest(request);//移给其他类处理            &#125;        &#125;    &#125;    class ConcreteHandler2 : Handler    &#123;        public override void HandleRequest(int request)        &#123;            if (request &gt;= 10 &amp;&amp; request &lt; 20)            &#123;                Console.WriteLine(&quot;处理请求&quot;, this.GetType().Name, request);            &#125;            else if (successor != null)            &#123;                successor.HandleRequest(request);//移给其他类处理            &#125;        &#125;    &#125;    class ConcreteHandler3 : Handler    &#123;        public override void HandleRequest(int request)        &#123;            if (request &gt;= 20 &amp;&amp; request &lt; 30)            &#123;                Console.WriteLine(&quot;处理请求&quot;, this.GetType().Name, request);            &#125;            else if (successor != null)            &#123;                successor.HandleRequest(request);//移给其他类处理            &#125;        &#125;    &#125;\n\n责任链模式总结\n类有太多的责任，这违背了单一职责原则，增加新的管理类，又违背了开放-封闭原则。\n将各种管理者类别分离开来，均作为管理者的子类，利用多态来化解分支判断的僵化。\n用一些“关联”来将管理类中的责任传递，用于把用户的请求传递，直到遇到可以解决这个请求的管理类为止。\n\n责任链的好处当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。\n接收者和发送者都没有对方的明确信息，且链中对象自己也并不知道链的结构。结果是责任链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选者的引用。大大降低了耦合度。  \n随时地增加或处理一个请求的结构。增强了给对象指派职责的灵活性。\n潜在的问题一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"设计模式总览","url":"/2023/04/12/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88/","content":"设计模式总览常见代码不规范之处：\n\n判断分支时总是只会使用多个if—else语句，增加无谓的操作（判断）\n命名规范\n总是忽略异常处理\n\n面向对象编程和活字印刷的类比活字印刷将每一个字单独拿出来制一个嵌，\n需要用到新的字的时候，再新刻一些——便于维护、可拓展性良好\n如果用不到新的字，就通过将旧的嵌组合在一起来印刷——可复用\n可以用多个字组成不同的句子、诗篇、文章去印刷——灵活性好\n\n可维护\n\n可复用\n\n可拓展\n\n灵活性好\n\n\n正是面向对象编程所需要达到的。\n面向对象编程-封装\n-继承\n-多态\n-设计模式\n封装、继承、多态——降低了程序的耦合度\n设计模式——使程序更加灵活、易于复用\n复制vs复用复用——尽可能避免重复\n业务的封装业务逻辑与界面逻辑分开\nUML类图—&gt;UML类图\n2022/4/1\n总是找抽象类或接口来解决问题，而不要找具体的实现类，强调了面向接口编程的思想。\n2022/4/17\n设计模式有很多，但实际上很多设计模式都在围绕着设计原则为核心进行结构设计，是一种实际运用，更加深入地理解设计原则才能真正运用好设计模式。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"适配器模式（Adaptor）","url":"/2023/04/12/DesignPattern/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adaptor%EF%BC%89/","content":"适配器模式（Adaptor）适配器模式动机\n能够使类和对象结合到一起形成更大的结构。\n适配器模式结构图\n适配器模式成员分析适配器模式（Adapter）包含以下主要角色。\n\n目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。\n适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。\n适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。\n\n适配器模式代码结构适配器模式代码实现：/// 客户所期待的接口。目标为具体/抽象的类，也可以是接口class Target&#123;    public virtual void Request()    &#123;        Console.WriteLine(&quot;普通请求&quot;);    &#125;&#125;/// 需要适配的类class Adaptee&#123;    public void SpecificRequest()    &#123;        Console.WriteLine(&quot;特殊请求&quot;);    &#125;&#125;class Adapter : Target&#123;    private Adaptee adaptee = new Adaptee();//建立一个私有的Adaptee对象    public override void Request()    &#123;        adaptee.SpecificRequest();        //这样可以表面上调用Request（）方法        //变成实际调用SpecificRequest（）方法    &#125;&#125;//客户端Target target = new Adapter();target.Request();\n\n适配器模式总结适配器模式（Adapter），将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类能够一起工作。\n适配器模式主要解决什么问题？\n简单地说，就是需要使用的东西完整，但却不能使用，而短时间内又无法改造它，于是我们就想办法适配它。  \n\n适配的意思就是使得一个东西适合另一个东西。  \n\n在软件开发中，系统的数据和行为都正确，但是接口不符合时，可用使用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用与希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。  \n\n对象适配器模式——适用于支持单继承（只能有一个父类）的语言\n\n\n什么时候使用适配器模式？\n使用一个存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑使用适配器模式。  \n\n两个类所做的事情相同或者相似，但是具有不同的接口时要使用适配器模式。\n\n\n什么时候都要使用适配器模式嘛？不对！！！\n如果能事先预防接口不同的问题，不匹配问题就不会发生，在小的接口不统一问题发生时，及时重构，问题不至于扩大；只有碰到无法改变原有设计和代码的情况时，才考虑适配。\n事后控制不如事中控制，事中控制不如事前控制。  \n适配器模式相当于事后控制的一种方式，如果无视它的应用场合盲目使用，反而是本末倒置。  \n在阅读适配器模式的实现的时候，我就直觉，这个模式不能到处乱用，看着就觉得很奇怪，到底这种模式有啥用、做了啥什么的。\n适配器模式优点将目标类和适配器类解耦，增加了类的复用性和透明性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”。\n适配器模式实例——耳机、充电一孔多用途//适配者类public class AirPlus &#123;    public void listen() &#123;        System.out.print(&quot;听.....&quot;);    &#125;&#125;//目标抽象类public interface Ipad &#123;    public void chongdian();//平板只有充电器接口&#125;//适配器类public class IpadAdapter extends AirPlus implements Ipad&#123;    public void chongdian() &#123;        System.out.print(&quot;使用平板&quot;);        super.listen();//调用耳机的听的方法，相当于不同插头的转接    &#125;&#125;//客户端调用public class Client &#123;    public static void main(String[] args) &#123;        AirPlus airplus=new AirPlus();        Ipad i=new IpadAdapter();        i.chongdian();    &#125;&#125;\n\n缺省适配器模式缺省适配器模式是适配器模式的一种变形，但其使用也非常广泛。  \n缺省适配器模式（Default Adapter Pattern）定义：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择的覆盖父类的某些方法来实现需求。  \n适用于一个接口不想使用其所有方法的情况，因此也称为单接口适配器模式。\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"迭代器模式（Iterator）","url":"/2023/04/12/DesignPattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator%EF%BC%89/","content":"迭代器模式（Iterator）迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。  \n当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，就可以考虑使用迭代器模式。  \n迭代器为遍历不同的聚集结构提供如：开始、下一个、是否结束、当前哪一项等统一的接口。  \n此外，可以知悉，基本上所有的高级语言都封装了迭代器的实现，直接将此模式做在了语言当中。  \n如：Foreach in（C#），IEnumerable接口等\n为什么将迭代器抽象成接口？  \n迭代方式的不同，可以使用不同的迭代器进行迭代  \n比如说我想要实现从后往前迭代——就可以通过实现迭代器接口实现  \n这样允许对聚集有多种方式遍历——可以考虑使用迭代器模式。\n迭代器模式结构图\n迭代器模式成员分析聚集Aggregatee，\n迭代器Iterator,\n迭代器代码结构代码实现:    /// &lt;summary&gt;    /// 抽象迭代器类    /// &lt;/summary&gt;    abstract class Iterator    &#123;        public abstract object First();//开始的对象        public abstract object Next();//得到下一个对象        public abstract bool IsDone();//是否到达尾部，遍历完成        public abstract object CurItem();//当前对象    &#125;    /// &lt;summary&gt;    /// 抽象聚集类    /// &lt;/summary&gt;    abstract class Aggregate    &#123;        public abstract Iterator CreateIterator();//创建迭代器    &#125;    /// &lt;summary&gt;    /// 具体迭代器类    /// &lt;/summary&gt;    class ConcreteIterator : Iterator    &#123;        private ConcreteAggregate aggregate;//定义了一个具体聚集对象        private int current = 0;        public ConcreteIterator(ConcreteAggregate aggregate)        &#123;            this.aggregate = aggregate;        &#125;        public override object CurItem()        &#123;            return aggregate[current];        &#125;        public override object First()        &#123;            return aggregate[0];        &#125;        public override bool IsDone()        &#123;            return current &gt;= aggregate.Count ? true : false;        &#125;        public override object Next()        &#123;            object ret = null;            current++;            if(current&lt;aggregate.Count)            &#123;                ret = aggregate[current];            &#125;            return ret;        &#125;    &#125;    /// &lt;summary&gt;    /// 具体聚集类    /// &lt;/summary&gt;    class ConcreteAggregate : Aggregate    &#123;        private IList&lt;Object&gt; items = new List&lt;object&gt;();        public int Count        &#123;            get &#123; return items.Count; &#125;        &#125;        public override Iterator CreateIterator()        &#123;            return new ConcreteIterator(this);        &#125;        public object this[int index]        &#123;            get &#123; return items[index]; &#125;            set &#123;items.Insert(index,value); &#125;        &#125;    &#125;//客户端代码ConcreteAggregate a = new ConcreteAggregate();a[0] = &quot;迭代0&quot;;a[1] = &quot;迭代1&quot;;a[2] = &quot;迭代2&quot;;Iterator i = new ConcreteIterator(a);object item = i.First();while (!i.IsDone())&#123;    Console.WriteLine(i.CurItem());    i.Next();&#125;\n\n迭代器模式总结\n迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据。  \n\n迭代器模式在访问数组、集合、列表等数据时，尤其是数据库数据操作时，非常普遍且适用。  \n\n基本上高级语言都对迭代器进行了封装。\n\n\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"测试Tags和Categories","url":"/2023/03/27/folder/%E6%B5%8B%E8%AF%95Tags%E5%92%8CCategories/","content":"\n这是标题一这是正文。\n","categories":["--[HelloWorld] --[技术杂项]"],"tags":["hexo","helloworld"]},{"title":"UML类图","url":"/2023/04/12/DesignPattern/Additions/UML%E7%B1%BB%E5%9B%BE/","content":"UML类图作为设计模式内容的补充\n在UML类图中，常见的有以下几种关系:泛化（Generalization）, 实现（Realization）,关联（Association）,聚合（Aggregation）,组合(Composition)，依赖(Dependency)\n1.泛化(Generalization)【泛化关系】：是一种继承关系,它指定了子类如何特化父类的所有特征和行为例如：老虎是动物的一种.\n【箭头指向】：带三角箭头的实线，箭头指向父类\n\n2.实现（Realization)【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现\n【箭头指向】：带三角箭头的虚线，箭头指向接口\n\n3.关联（Association）【关联关系】：是一种拥有的关系,它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子\n关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。\n【代码体现】：成员变量\n【箭头及指向】：带普通箭头的实心线，指向被拥有者\n\n\n上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。\n上图为自身关联：\n4.聚合（Aggregation）【聚合关系】：是整体与部分的关系.如车和轮胎是整体和部分的关系.\n聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。\n【代码体现】：成员变量\n【箭头及指向】：带空心菱形的实心线，菱形指向整体\n\n5.组合(Composition)【组合关系】：是整体与部分的关系.,没有公司就不存在部门 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期\n例如：人的器官组成人的整体，当人死亡时，器官也跟着死亡。\n【代码体现】：成员变量\n【箭头及指向】：带实心菱形的实线，菱形指向整体\n\n6.依赖(Dependency)【依赖关系】：是一种使用的关系,所以要尽量不使用双向的互相依赖。\n【代码表现】：局部变量、方法的参数或者对静态方法的调用\n【箭头及指向】：带箭头的虚线，指向被使用者\n\n各种关系的强弱顺序：泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖\n下面这张UML图，比较形象地展示了各种类图关系：\n","categories":["--[设计模式]"],"tags":["设计模式"]},{"title":"反射","url":"/2023/04/12/DesignPattern/Additions/%E5%8F%8D%E5%B0%84/","content":"反射作为设计模式的补充内容\n反射的实例","categories":["--[反射]"],"tags":["设计模式","反射"]},{"title":"事件和委托","url":"/2023/04/12/DesignPattern/Additions/%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/","content":"事件和委托作为设计模式的补充内容\n委托就是一种引用方法的类型。\n一旦为委托分配了方法，委托将与该方法具有完全相同的行为。\n委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的“类”，委托的实例将代表一个具体的函数。\n一个委托可以搭载多个方法，所有方法将被依次唤起。\n重要的是：它可以使得委托对象所搭载的方法并不需要属于同一个类。\n委托对象所搭载的所有方法必须具有相同的原形和形式——具有相同的参数表列和返回值类型。\n","categories":["--[设计模式]"],"tags":["设计模式","事件","委托"]},{"title":"依赖倒置原则","url":"/2023/04/12/DesignPattern/DesignPrinciples/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/","content":"依赖倒置原则依赖倒置原则说的是：\n\n高层模块不应该依赖低层模块，两个都应该依赖于抽象。\n\n抽象不应该依赖细节，细节应该依赖于抽象。\n\n就是说，要针对接口编程，不要对实现编程。\n\n\n\n依赖倒置其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中的所有依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计。\n只要接口是稳定的，那么任何一个的更改都不用担心受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。\n做项目的时候，通常需要访问数据库，为了使代码能够重用，可以用一个DatabaseUtil类来装关于数据库的各种操作，然后再根据业务逻辑调用其中的各种方法来操作数据库。可以想到，业务逻辑层依赖于数据库操作层（高层依赖于低层），如果要做新项目的时候，发现业务逻辑的高层模块基本是一样的，但却要使用另外的数据库，我们想要复用业务逻辑层，但是却发现了窘境：这些业务逻辑都和低层绑定在一起，没办法复用这些模块。\n如果想要复用这些模块，就需要类似实现像电脑cpu，内存，硬盘那样在主板上即插即用的接口*。主板坏了，会影响其他部件的使用，但是单一个内存坏了，不应该影响到其他部件的使用。提供统一的接口，才是让高层模块和低层模块都能复用的真理…\n只要行为是一致的，就可以通过接口的引用（父）来装载子类（实现该接口的类）。只要实例化对应的子类，不需要修改接口方法的调用。这样就实现了对高层模块的复用。\n","categories":["--[设计模式,设计原则]"],"tags":["设计模式"]},{"title":"浅表复制和深层复制","url":"/2023/04/12/DesignPattern/Additions/%E6%B5%85%E8%A1%A8%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%B1%82%E5%A4%8D%E5%88%B6/","content":"浅表复制和深层复制设计模式的补充内容\n关于浅表复制和深层复制string类型是一种拥有值类型特点的特殊引用类型，MemberwiseClone方法是这样进行的：如果字段是值类型的，则对该字段执行逐位复制，如果字段是引用类型，则复制引用但不复制引用的对象：因此原始对象及其副本引用同一对象。\n为什么不能同步复制过来呢？这就是复制引用和复制数值的区别。\n复制了引用，新对象指向的仍然是同一个堆。\n“浅复制”，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。\n“深复制”，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。\n","categories":["--[设计模式]"],"tags":["设计模式","copy"]},{"title":"单一职责原则","url":"/2023/04/12/DesignPattern/DesignPrinciples/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/","content":"单一职责原则就一个类而言，应该仅有一个引起它变化的原因。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。想要避免这种现象的发生，就要尽可能的遵守单一职责原则。\n单一职责原则的核心就是解耦和增强内聚性。\n软件设计真正需要做的内容，就是发现职责并把那些职责相互分离。\n如果发现多于一个的动机去改变一个类，那么这个类就具有多于一个职责耦合在一起。\n","categories":["--[设计模式,设计原则]"],"tags":["设计模式"]},{"title":"合成/聚合复用原则（CAPR）","url":"/2023/04/12/DesignPattern/DesignPrinciples/%E5%90%88%E6%88%90-%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%88CAPR%EF%BC%89/","content":"合成/聚合复用原则（CAPR）对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变换必然导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。\n合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。\n聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；\n合成则是一种强的“拥有”关系，体现了严格的部分与整体的关系，部分和整体的生命周期一样。\n优先使用对象的合成聚合将有助于你保持每个类被封装，并被集中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。\n继承表示了父子之间的强耦合关系。\n所以说，不要乱用继承。\n","categories":["--[设计模式,设计原则]"],"tags":["设计模式"]},{"title":"开放封闭原则","url":"/2023/04/12/DesignPattern/DesignPrinciples/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99/","content":"开放封闭原则The Open-Closed Principle开闭原则说的是软件实体（类、模块、函数等）应该是可以拓展，但是不可修改的。\n两个特征:\n对于拓展是开放的（Open for Extension）\n对于修改是封闭的（Closed for modification）\n在做任何系统时，不必指望系统需求一开始就是确定的，因为需求一定会更改，要设计出容易维护又不容易出问题的软件系统，最好就是多拓展，少修改。怎么样的设计才能面对需求的改变而保持相对稳定呢？\n拓展性问题\n保留拓展点\n要时刻具备拓展意识、抽象意识和封装意识\n\n修改问题\n添加了新类、新模块，但仍需要对高层模块作些许修改以适应新业务。\n尽量让修改更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。\n绝对的对修改关闭是不存在的、不可能的。\n无论模块多么“封闭”，都存在无法对之封闭的变化，设计人员必须对他设计的模块应该对哪种变化封闭做出选择，他必须猜测最有可能发生的变化种类，然后抽象隔离出那些变化。\n等到变化发生时立即采取行动\n在最开始编写时，假设变化不会发生，当变化发生时，我们就创建抽象来隔离发生的同类变化。\n\n例子：运算类——添加一个新的运算刚开始的时候，这个运算整个写在控制台，如果要添加一个新的运算操作，需要修改整个程序结构。\n后面通过抽象，继承的方式，将不同的运算操作分离开来，如果要添加一个新的运算操作，就直接新建一个类继承运算类重写虚方法。\n面对需求，对程序的改动是通过增加新代码实现的（拓展），而不是修改原来的代码做出来的（减少修改）。\n并非对于应用程序的每个部分都刻意进行抽象，拒绝这样的过度抽象，拒绝不成熟的抽象和学会使用抽象一样重要。\n如何做到“对扩展开放、修改关闭”？实际上，开闭原则讲的就是代码****的扩展性问题，是判断一段代码是否易扩展的“金标准”。\n在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。\n扩展意识在写代码的时候，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。\n抽象意识提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换老的实现即可，上游系统的代码几乎不需要修改。\n封装意识在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化。\n实现在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如：装饰、策略、模板、职责链、状态等）。\n预留扩展点前面我们提到，写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点，那么问题是，应该如何才能识别出所有可能的扩展点呢？\n如果开发业务导向的系统，比如电商系统、物流系统、金融系统等，要想识别尽可能多的扩展点，就需要对业务本身有足够多的了解。\n如果开发通用、偏底层的框架、类库、组件等，就需要了解它们会被如何使用，日后可能会添加什么功能。\n过度设计的问题“唯一不变的就是变化本身”，尽管我们对业务系统、框架功能有足够多的了解，也不能识别出所有的扩展点。即便我们能够识别出所有的扩展点，为这些地方做预留扩展点的设计，成本都是很大的，这就叫做“过度设计”。\n合理的做法应该是对于一些比较确定的，短期内可能就会扩展，或者需要改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候，我们就可以事先做预留扩展点设计。但是对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，可以通过重构代码的方式来支持扩展的需求。\n设计原则是否应用得当，应该根据具体的业务场景，具体分析。\n总结\n对扩展开放，是为了应付变化（需求）；\n\n对修改封闭，是为了保证已有代码的稳定性；\n\n最终结果是为了让系统更有弹性！\n\n\n","categories":["--[设计模式,设计原则]"],"tags":["设计模式"]},{"title":"敏捷开发原则","url":"/2023/04/12/DesignPattern/DesignPrinciples/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/","content":"敏捷开发原则不要为代码添加基于猜测的、实际不需要的功能。\n敏捷开发的12条原则\n","categories":["--[设计模式,设计原则]"],"tags":["设计模式"]},{"title":"迪米特法则","url":"/2023/04/12/DesignPattern/DesignPrinciples/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/","content":"迪米特法则迪米特法则，也叫最少知识原则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。\n迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。类应当尽量包装好自己的状态为private，不让别的类知道的字段和行为不必公开。需要公开的字段通常通过属性来体现。（C#尤其如此）\n迪米特法则其根本思想，是强调了类之间的松耦合。\n类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。信息的隐藏促进了软件的复用。\n","categories":["--[设计模式,设计原则]"],"tags":["设计模式"]},{"title":"里氏替换原则","url":"/2023/04/12/DesignPattern/DesignPrinciples/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/","content":"里氏替换原则一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。  \n也就是说，在软件里面，把父类都替换成他的子类，程序的行为没有变化。  \n更加简单地：父类引用可以装载子类实例。\n当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能被真正被复用，而子类也能在父类的基础上面增加新的行为。  \n由于子类型的可替换性才使得父类的模块在无需修改的情况下可以拓展。\n里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。\n里氏替换原则的作用里氏替换原则的主要作用如下。\n\n里氏替换原则是实现开闭原则的重要方式之一。\n它克服了继承中重写父类造成的可复用性变差的缺点。\n它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。\n加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。\n\n里氏替换原则的实现方法里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n根据上述理解，对里氏替换原则的定义可以总结如下：\n\n子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法\n子类中可以增加自己特有的方法\n当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松\n当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等\n\n通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。\n如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。\n关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。\n什么是替换？替换的前提是面向对象语言所支持的多态特性，同一个行为具有多个不同表现形式或形态的能力。以JDK的集合框架为例，List接口的定义为有序集合，List接口有多个派生类，比如大家耳熟能详的ArrayList, LinkedList。那当某个方法参数或变量是List接口类型时，既可以是ArrayList的实现, 也可以是LinkedList的实现，这就是替换。\n举个简单的例子：\npublic String getFirst(List&lt;String&gt; values) &#123;    return values.get(0); &#125;//对于getFirst方法，接受一个List接口类型的参数，//那既可以传递一个ArrayList类型的参数：List&lt;String&gt; values = new ArrayList&lt;&gt;();values.add(&quot;a&quot;);values.add(&quot;b&quot;);String firstValue = getFirst(values);//也可以接收一个LinkedList参数：List&lt;String&gt; values = new LinkedList&lt;&gt;();values.add(&quot;a&quot;);values.add(&quot;b&quot;);String firstValue = getFirst(values);\n\n什么是与期望行为一致的替换？在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派生类的实现，都与接口或基类方法的期望行为一致。或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。继续以上节中的例子说明： \npublic String getFirst(List&lt;String&gt; values) &#123;    return values.get(0);&#125;\n\n对于getFirst方法，接收List类型的参数，而List类型的get方法返回特定位置的元素，对于本例即为第一个元素。这些是不依赖派生类的知识的。所以对于上节中的示例，不管是ArrayList类型的实现，还是LinkedList的实现，getFirst方法最终的返回值是一样的。这就是与期望行为一致的替换。  \n违反里氏替换原则的场景：  \n\n子类种抛出了基类中未定义的异常。\n\n子类改变了基类定义的方法的语义（引入了副作用）。\n\n\n违反里氏替换原则的危害反直觉。期望所有的子类行为均一致，但若非一致则需要文档记录。  \n不可读。如果子类行为不一致，可能需要不同的逻辑分支来适配不同的行为，徒增代码复杂度。  \n不可用。可能出错的地方终将出错。\n如何避免违反里氏替换原则谈到如何避免，当然要基于里氏替换原则的定义，与期望行为一致的替换。\n\n从行为出发来设计。在做抽象或设计时，不只是要从模型概念出发，还要从行为出发，比如一个经典的例子，正方形和长方形，从现实的概念中正方形是一个长方形，但是在计算其面积的行为上是不一致的。\n基于契约设计。这个契约即是基类方法签名、功能描述、参数类型、返回值等。在派生类的实现时，时刻保持派生类与基类的契约不被破坏。\n\n","categories":["--[设计模式,设计原则]"],"tags":["设计模式"]}]